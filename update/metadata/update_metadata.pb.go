// Code generated by protoc-gen-go.
// source: update_metadata.proto
// DO NOT EDIT!

/*
Package metadata is a generated protocol buffer package.

It is generated from these files:
	update_metadata.proto

It has these top-level messages:
	InstallOperation
	Extent
	Signatures
	InstallInfo
	InstallProcedure
	DeltaArchiveManifest
*/
package metadata

import proto "github.com/coreos/mantle/Godeps/_workspace/src/github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

type InstallOperation_Type int32

const (
	InstallOperation_REPLACE    InstallOperation_Type = 0
	InstallOperation_REPLACE_BZ InstallOperation_Type = 1
	InstallOperation_MOVE       InstallOperation_Type = 2
	InstallOperation_BSDIFF     InstallOperation_Type = 3
)

var InstallOperation_Type_name = map[int32]string{
	0: "REPLACE",
	1: "REPLACE_BZ",
	2: "MOVE",
	3: "BSDIFF",
}
var InstallOperation_Type_value = map[string]int32{
	"REPLACE":    0,
	"REPLACE_BZ": 1,
	"MOVE":       2,
	"BSDIFF":     3,
}

func (x InstallOperation_Type) Enum() *InstallOperation_Type {
	p := new(InstallOperation_Type)
	*p = x
	return p
}
func (x InstallOperation_Type) String() string {
	return proto.EnumName(InstallOperation_Type_name, int32(x))
}
func (x *InstallOperation_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(InstallOperation_Type_value, data, "InstallOperation_Type")
	if err != nil {
		return err
	}
	*x = InstallOperation_Type(value)
	return nil
}
func (InstallOperation_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

type InstallProcedure_Type int32

const (
	InstallProcedure_KERNEL InstallProcedure_Type = 0
)

var InstallProcedure_Type_name = map[int32]string{
	0: "KERNEL",
}
var InstallProcedure_Type_value = map[string]int32{
	"KERNEL": 0,
}

func (x InstallProcedure_Type) Enum() *InstallProcedure_Type {
	p := new(InstallProcedure_Type)
	*p = x
	return p
}
func (x InstallProcedure_Type) String() string {
	return proto.EnumName(InstallProcedure_Type_name, int32(x))
}
func (x *InstallProcedure_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(InstallProcedure_Type_value, data, "InstallProcedure_Type")
	if err != nil {
		return err
	}
	*x = InstallProcedure_Type(value)
	return nil
}
func (InstallProcedure_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

// The client will perform each InstallOperation in order, beginning even
// before the entire delta file is downloaded (but after at least the
// protobuf is downloaded). The types of operations are explained:
// - REPLACE: Replace the dst_extents on the drive with the attached data,
//   zero padding out to block size.
// - REPLACE_BZ: bzip2-uncompress the attached data and write it into
//   dst_extents on the drive, zero padding to block size.
// - MOVE: Copy the data in src_extents to dst_extents. Extents may overlap,
//   so it may be desirable to read all src_extents data into memory before
//   writing it out.
// - BSDIFF: Read src_length bytes from src_extents into memory, perform
//   bspatch with attached data, write new data to dst_extents, zero padding
//   to block size.
type InstallOperation struct {
	Type *InstallOperation_Type `protobuf:"varint,1,req,name=type,enum=chromeos_update_engine.InstallOperation_Type" json:"type,omitempty"`
	// The offset into the delta file (after the protobuf)
	// where the data (if any) is stored
	DataOffset *uint32 `protobuf:"varint,2,opt,name=data_offset" json:"data_offset,omitempty"`
	// The length of the data in the delta file
	DataLength *uint32 `protobuf:"varint,3,opt,name=data_length" json:"data_length,omitempty"`
	// Ordered list of extents that are read from (if any) and written to.
	SrcExtents []*Extent `protobuf:"bytes,4,rep,name=src_extents" json:"src_extents,omitempty"`
	// Byte length of src, not necessarily block aligned. It's only used for
	// BSDIFF, because we need to pass that external program the number
	// of bytes to read from the blocks we pass it.
	SrcLength  *uint64   `protobuf:"varint,5,opt,name=src_length" json:"src_length,omitempty"`
	DstExtents []*Extent `protobuf:"bytes,6,rep,name=dst_extents" json:"dst_extents,omitempty"`
	// byte length of dst, not necessarily block aligned. It's only used for
	// BSDIFF, because we need to fill in the rest of the last block
	// that bsdiff writes with '\0' bytes.
	DstLength *uint64 `protobuf:"varint,7,opt,name=dst_length" json:"dst_length,omitempty"`
	// Optional SHA 256 hash of the blob associated with this operation.
	// This is used as a primary validation for http-based downloads and
	// as a defense-in-depth validation for https-based downloads. If
	// the operation doesn't refer to any blob, this field will have
	// zero bytes.
	DataSha256Hash   []byte `protobuf:"bytes,8,opt,name=data_sha256_hash" json:"data_sha256_hash,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *InstallOperation) Reset()                    { *m = InstallOperation{} }
func (m *InstallOperation) String() string            { return proto.CompactTextString(m) }
func (*InstallOperation) ProtoMessage()               {}
func (*InstallOperation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *InstallOperation) GetType() InstallOperation_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return InstallOperation_REPLACE
}

func (m *InstallOperation) GetDataOffset() uint32 {
	if m != nil && m.DataOffset != nil {
		return *m.DataOffset
	}
	return 0
}

func (m *InstallOperation) GetDataLength() uint32 {
	if m != nil && m.DataLength != nil {
		return *m.DataLength
	}
	return 0
}

func (m *InstallOperation) GetSrcExtents() []*Extent {
	if m != nil {
		return m.SrcExtents
	}
	return nil
}

func (m *InstallOperation) GetSrcLength() uint64 {
	if m != nil && m.SrcLength != nil {
		return *m.SrcLength
	}
	return 0
}

func (m *InstallOperation) GetDstExtents() []*Extent {
	if m != nil {
		return m.DstExtents
	}
	return nil
}

func (m *InstallOperation) GetDstLength() uint64 {
	if m != nil && m.DstLength != nil {
		return *m.DstLength
	}
	return 0
}

func (m *InstallOperation) GetDataSha256Hash() []byte {
	if m != nil {
		return m.DataSha256Hash
	}
	return nil
}

// Data is packed into blocks on disk, always starting from the beginning
// of the block. If a file's data is too large for one block, it overflows
// into another block, which may or may not be the following block on the
// physical partition. An ordered list of extents is another
// representation of an ordered list of blocks. For example, a file stored
// in blocks 9, 10, 11, 2, 18, 12 (in that order) would be stored in
// extents { {9, 3}, {2, 1}, {18, 1}, {12, 1} } (in that order).
// In general, files are stored sequentially on disk, so it's more efficient
// to use extents to encode the block lists (this is effectively
// run-length encoding).
// A sentinel value (UINT64_MAX) as the start block denotes a sparse-hole
// in a file whose block-length is specified by num_blocks.
type Extent struct {
	StartBlock       *uint64 `protobuf:"varint,1,opt,name=start_block" json:"start_block,omitempty"`
	NumBlocks        *uint64 `protobuf:"varint,2,opt,name=num_blocks" json:"num_blocks,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Extent) Reset()                    { *m = Extent{} }
func (m *Extent) String() string            { return proto.CompactTextString(m) }
func (*Extent) ProtoMessage()               {}
func (*Extent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Extent) GetStartBlock() uint64 {
	if m != nil && m.StartBlock != nil {
		return *m.StartBlock
	}
	return 0
}

func (m *Extent) GetNumBlocks() uint64 {
	if m != nil && m.NumBlocks != nil {
		return *m.NumBlocks
	}
	return 0
}

// Signatures: Updates may be signed by the OS vendor. The client verifies
// an update's signature by hashing the entire download. The section of the
// download that contains the signature is at the end of the file, so when
// signing a file, only the part up to the signature part is signed.
// Then, the client looks inside the download's Signatures message for a
// Signature message that it knows how to handle. Generally, a client will
// only know how to handle one type of signature, but an update may contain
// many signatures to support many different types of client. Then client
// selects a Signature message and uses that, along with a known public key,
// to verify the download. The public key is expected to be part of the
// client.
type Signatures struct {
	Signatures       []*Signatures_Signature `protobuf:"bytes,1,rep,name=signatures" json:"signatures,omitempty"`
	XXX_unrecognized []byte                  `json:"-"`
}

func (m *Signatures) Reset()                    { *m = Signatures{} }
func (m *Signatures) String() string            { return proto.CompactTextString(m) }
func (*Signatures) ProtoMessage()               {}
func (*Signatures) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Signatures) GetSignatures() []*Signatures_Signature {
	if m != nil {
		return m.Signatures
	}
	return nil
}

type Signatures_Signature struct {
	Version          *uint32 `protobuf:"varint,1,opt,name=version" json:"version,omitempty"`
	Data             []byte  `protobuf:"bytes,2,opt,name=data" json:"data,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Signatures_Signature) Reset()                    { *m = Signatures_Signature{} }
func (m *Signatures_Signature) String() string            { return proto.CompactTextString(m) }
func (*Signatures_Signature) ProtoMessage()               {}
func (*Signatures_Signature) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

func (m *Signatures_Signature) GetVersion() uint32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func (m *Signatures_Signature) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type InstallInfo struct {
	Size             *uint64 `protobuf:"varint,1,opt,name=size" json:"size,omitempty"`
	Hash             []byte  `protobuf:"bytes,2,opt,name=hash" json:"hash,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *InstallInfo) Reset()                    { *m = InstallInfo{} }
func (m *InstallInfo) String() string            { return proto.CompactTextString(m) }
func (*InstallInfo) ProtoMessage()               {}
func (*InstallInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *InstallInfo) GetSize() uint64 {
	if m != nil && m.Size != nil {
		return *m.Size
	}
	return 0
}

func (m *InstallInfo) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

// InstallProcedure defines the update procedure for a single file or block
// device (except for /usr which is in DeltaArchiveManifest).
type InstallProcedure struct {
	Type             *InstallProcedure_Type `protobuf:"varint,1,req,name=type,enum=chromeos_update_engine.InstallProcedure_Type" json:"type,omitempty"`
	Operations       []*InstallOperation    `protobuf:"bytes,2,rep,name=operations" json:"operations,omitempty"`
	OldInfo          *InstallInfo           `protobuf:"bytes,3,opt,name=old_info" json:"old_info,omitempty"`
	NewInfo          *InstallInfo           `protobuf:"bytes,4,opt,name=new_info" json:"new_info,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *InstallProcedure) Reset()                    { *m = InstallProcedure{} }
func (m *InstallProcedure) String() string            { return proto.CompactTextString(m) }
func (*InstallProcedure) ProtoMessage()               {}
func (*InstallProcedure) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *InstallProcedure) GetType() InstallProcedure_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return InstallProcedure_KERNEL
}

func (m *InstallProcedure) GetOperations() []*InstallOperation {
	if m != nil {
		return m.Operations
	}
	return nil
}

func (m *InstallProcedure) GetOldInfo() *InstallInfo {
	if m != nil {
		return m.OldInfo
	}
	return nil
}

func (m *InstallProcedure) GetNewInfo() *InstallInfo {
	if m != nil {
		return m.NewInfo
	}
	return nil
}

type DeltaArchiveManifest struct {
	// The update procedure for the main partition (USR-A or USR-B). Once
	// complete it should match the hash specified in new_partition_info.
	PartitionOperations []*InstallOperation `protobuf:"bytes,1,rep,name=partition_operations" json:"partition_operations,omitempty"`
	// This field is maintained for compatibility with older update_engine
	// clients. In the ChromeOS days it covered the kernel partition but in
	// CoreOS it has only been used to insert a dummy operation to account for
	// the signatures tacked onto the end of the payload. The code was not smart
	// enough to stop passing data to the filesystem writer code after the
	// signatures_offset had been reached, instead using the magic punch-hole
	// value to skip over the extra data. Since CoreOS versions of update_engine
	// only partially removed support kernel partitions passing anything other
	// than dummy operations will trigger broken code paths but omitting the
	// dummy operations will fail when the filesystem writer receives unexpected
	// data. Therefore to work with old versions it strictly *must* look like:
	//
	//   noop_operations: {
	//     type: REPLACE
	//     data_offset: signatures_offset
	//     data_length: signatures_size
	//     dst_extents: {
	//       start_block: UINT64_MAX
	//       num_blocks: (signature_size + block_size - 1) / block_size
	//     }
	//   }
	//
	NoopOperations []*InstallOperation `protobuf:"bytes,2,rep,name=noop_operations" json:"noop_operations,omitempty"`
	// (At time of writing) usually 4096
	BlockSize *uint32 `protobuf:"varint,3,opt,name=block_size,def=4096" json:"block_size,omitempty"`
	// If signatures are present, the offset into the blobs, generally
	// tacked onto the end of the file, and the length. We use an offset
	// rather than a bool to allow for more flexibility in future file formats.
	// If either is absent, it means signatures aren't supported in this
	// file.
	SignaturesOffset *uint64 `protobuf:"varint,4,opt,name=signatures_offset" json:"signatures_offset,omitempty"`
	SignaturesSize   *uint64 `protobuf:"varint,5,opt,name=signatures_size" json:"signatures_size,omitempty"`
	// Partition data that can be used to validate the update.
	OldPartitionInfo *InstallInfo `protobuf:"bytes,8,opt,name=old_partition_info" json:"old_partition_info,omitempty"`
	NewPartitionInfo *InstallInfo `protobuf:"bytes,9,opt,name=new_partition_info" json:"new_partition_info,omitempty"`
	// In addition to the partition update, process updates for additional
	// files, such as kernels. Versions of update_engine that can interpret
	// this list *MUST* ignore noop_operations and properly account for the
	// signature data at the end of the payload.
	Procedures       []*InstallProcedure `protobuf:"bytes,10,rep,name=procedures" json:"procedures,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *DeltaArchiveManifest) Reset()                    { *m = DeltaArchiveManifest{} }
func (m *DeltaArchiveManifest) String() string            { return proto.CompactTextString(m) }
func (*DeltaArchiveManifest) ProtoMessage()               {}
func (*DeltaArchiveManifest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

const Default_DeltaArchiveManifest_BlockSize uint32 = 4096

func (m *DeltaArchiveManifest) GetPartitionOperations() []*InstallOperation {
	if m != nil {
		return m.PartitionOperations
	}
	return nil
}

func (m *DeltaArchiveManifest) GetNoopOperations() []*InstallOperation {
	if m != nil {
		return m.NoopOperations
	}
	return nil
}

func (m *DeltaArchiveManifest) GetBlockSize() uint32 {
	if m != nil && m.BlockSize != nil {
		return *m.BlockSize
	}
	return Default_DeltaArchiveManifest_BlockSize
}

func (m *DeltaArchiveManifest) GetSignaturesOffset() uint64 {
	if m != nil && m.SignaturesOffset != nil {
		return *m.SignaturesOffset
	}
	return 0
}

func (m *DeltaArchiveManifest) GetSignaturesSize() uint64 {
	if m != nil && m.SignaturesSize != nil {
		return *m.SignaturesSize
	}
	return 0
}

func (m *DeltaArchiveManifest) GetOldPartitionInfo() *InstallInfo {
	if m != nil {
		return m.OldPartitionInfo
	}
	return nil
}

func (m *DeltaArchiveManifest) GetNewPartitionInfo() *InstallInfo {
	if m != nil {
		return m.NewPartitionInfo
	}
	return nil
}

func (m *DeltaArchiveManifest) GetProcedures() []*InstallProcedure {
	if m != nil {
		return m.Procedures
	}
	return nil
}

func init() {
	proto.RegisterType((*InstallOperation)(nil), "chromeos_update_engine.InstallOperation")
	proto.RegisterType((*Extent)(nil), "chromeos_update_engine.Extent")
	proto.RegisterType((*Signatures)(nil), "chromeos_update_engine.Signatures")
	proto.RegisterType((*Signatures_Signature)(nil), "chromeos_update_engine.Signatures.Signature")
	proto.RegisterType((*InstallInfo)(nil), "chromeos_update_engine.InstallInfo")
	proto.RegisterType((*InstallProcedure)(nil), "chromeos_update_engine.InstallProcedure")
	proto.RegisterType((*DeltaArchiveManifest)(nil), "chromeos_update_engine.DeltaArchiveManifest")
	proto.RegisterEnum("chromeos_update_engine.InstallOperation_Type", InstallOperation_Type_name, InstallOperation_Type_value)
	proto.RegisterEnum("chromeos_update_engine.InstallProcedure_Type", InstallProcedure_Type_name, InstallProcedure_Type_value)
}

var fileDescriptor0 = []byte{
	// 560 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xa4, 0x53, 0x5d, 0x6f, 0xd3, 0x30,
	0x14, 0x5d, 0xdb, 0xd0, 0x76, 0x37, 0xdd, 0x1a, 0xcc, 0x80, 0xc0, 0x03, 0xaa, 0xc2, 0x4b, 0x41,
	0x50, 0x41, 0x61, 0x93, 0x06, 0x48, 0xd0, 0xb1, 0x54, 0xaa, 0xd8, 0xd8, 0xb4, 0x21, 0x1e, 0x78,
	0xb1, 0x42, 0xeb, 0x2e, 0x11, 0xa9, 0x1d, 0xc5, 0xee, 0x80, 0xfd, 0x09, 0x7e, 0x0a, 0x7f, 0x89,
	0x9f, 0xc2, 0xb5, 0x9b, 0x26, 0xd3, 0xc4, 0x44, 0xa6, 0xbd, 0xf9, 0xeb, 0x9c, 0x7b, 0xcf, 0xb9,
	0xc7, 0x70, 0x7b, 0x9e, 0x4c, 0x02, 0xc5, 0xe8, 0x8c, 0xa9, 0x00, 0x17, 0x41, 0x2f, 0x49, 0x85,
	0x12, 0xe4, 0xce, 0x38, 0x4c, 0xc5, 0x8c, 0x09, 0x49, 0xb3, 0x7b, 0xc6, 0x4f, 0x22, 0xce, 0xbc,
	0x3f, 0x55, 0x70, 0x46, 0x5c, 0xaa, 0x20, 0x8e, 0x0f, 0x12, 0x96, 0x06, 0x2a, 0x12, 0x9c, 0xbc,
	0x06, 0x4b, 0xfd, 0x4c, 0x98, 0x5b, 0xe9, 0x54, 0xbb, 0xeb, 0xfd, 0xa7, 0xbd, 0x7f, 0x63, 0x7b,
	0x17, 0x71, 0xbd, 0x4f, 0x08, 0x22, 0xb7, 0xc0, 0xd6, 0x75, 0xa9, 0x98, 0x4e, 0x25, 0x53, 0x6e,
	0xb5, 0x53, 0xe9, 0xae, 0xe5, 0x87, 0x31, 0x42, 0x55, 0xe8, 0xd6, 0xcc, 0xe1, 0x0b, 0xb0, 0x65,
	0x3a, 0xa6, 0xec, 0x87, 0x62, 0x5c, 0x49, 0xd7, 0xea, 0xd4, 0xba, 0x76, 0xff, 0xc1, 0x65, 0xd5,
	0x7c, 0xf3, 0x8c, 0x10, 0x00, 0x0d, 0xca, 0x88, 0x6e, 0x20, 0x91, 0xa5, 0x89, 0x26, 0x52, 0xe5,
	0x44, 0xf5, 0xb2, 0x44, 0x1a, 0x94, 0x11, 0x35, 0x0c, 0x91, 0x0b, 0x8e, 0x69, 0x53, 0x86, 0x41,
	0x7f, 0x73, 0x8b, 0x86, 0x81, 0x0c, 0xdd, 0x26, 0xde, 0xb4, 0xbc, 0x6d, 0xb0, 0x8c, 0x3a, 0x1b,
	0x1a, 0x47, 0xfe, 0xe1, 0xde, 0xe0, 0xbd, 0xef, 0xac, 0x90, 0x75, 0x80, 0x6c, 0x43, 0x77, 0xbe,
	0x38, 0x15, 0xd2, 0x04, 0x6b, 0xff, 0xe0, 0xb3, 0xef, 0x54, 0x91, 0xbb, 0xbe, 0x73, 0xbc, 0x3b,
	0x1a, 0x0e, 0x9d, 0x9a, 0xf7, 0x1c, 0xea, 0x59, 0x49, 0x74, 0x01, 0x1d, 0x4b, 0x15, 0xfd, 0x1a,
	0x8b, 0xf1, 0x37, 0xb4, 0x57, 0xd7, 0xc4, 0xb7, 0x7c, 0x3e, 0x5b, 0x1c, 0x49, 0x63, 0x97, 0xe5,
	0x9d, 0x01, 0x1c, 0x47, 0x27, 0x3c, 0x50, 0xf3, 0x94, 0x49, 0xf2, 0x0e, 0x25, 0xe7, 0x3b, 0x44,
	0x69, 0x75, 0x4f, 0x2e, 0x53, 0x57, 0xe0, 0x8a, 0xe5, 0xfd, 0xc7, 0xb0, 0x9a, 0x6f, 0x48, 0x1b,
	0x1a, 0xa7, 0x2c, 0x95, 0x38, 0x30, 0xd3, 0xc1, 0x1a, 0x69, 0x81, 0xa5, 0x55, 0x9b, 0xda, 0x2d,
	0xef, 0x11, 0xd8, 0xd9, 0x60, 0x47, 0x7c, 0x2a, 0xf4, 0xa5, 0x8c, 0xce, 0x58, 0xd6, 0x2c, 0xee,
	0x8c, 0x29, 0x8b, 0xa7, 0xbf, 0x8a, 0xf0, 0x1c, 0xa6, 0x62, 0xcc, 0x26, 0x9a, 0xfe, 0x6a, 0xe1,
	0xc9, 0x71, 0x8b, 0xf0, 0xbc, 0x01, 0x10, 0xcb, 0x38, 0x69, 0x33, 0xb4, 0xd4, 0x6e, 0xd9, 0xfc,
	0x91, 0x4d, 0x68, 0x8a, 0x78, 0x42, 0x23, 0xec, 0xdb, 0x44, 0xcc, 0xee, 0x3f, 0xfc, 0x0f, 0xd6,
	0x48, 0x44, 0x18, 0x67, 0xdf, 0x17, 0x30, 0xab, 0x34, 0xcc, 0x23, 0x59, 0x24, 0x70, 0xd6, 0x1f,
	0xfc, 0xa3, 0x8f, 0xfe, 0x9e, 0xb3, 0xe2, 0xfd, 0xae, 0xc1, 0xc6, 0x2e, 0x8b, 0x55, 0x30, 0x48,
	0xc7, 0x61, 0x74, 0xca, 0xf6, 0x03, 0x1e, 0x4d, 0x99, 0x54, 0x64, 0x08, 0x1b, 0x09, 0x4e, 0x3e,
	0xd2, 0x7d, 0xd2, 0x73, 0x12, 0x2b, 0x57, 0x94, 0x38, 0x80, 0x36, 0x17, 0x22, 0xa1, 0xd7, 0x70,
	0xc9, 0x05, 0x30, 0x61, 0xa3, 0x66, 0xae, 0xe6, 0x2b, 0xbe, 0xb2, 0x5e, 0x3e, 0xdb, 0xde, 0x22,
	0xf7, 0xe0, 0x66, 0x11, 0xb4, 0xe5, 0x07, 0xb6, 0xcc, 0xe0, 0xef, 0x42, 0xfb, 0xdc, 0x95, 0x41,
	0x2e, 0xfe, 0xde, 0x5b, 0x20, 0xda, 0xf3, 0x42, 0x9c, 0xb1, 0xb1, 0x59, 0xde, 0x7d, 0x24, 0xd0,
	0xee, 0x5f, 0x20, 0x58, 0x2d, 0x4f, 0x80, 0x99, 0x49, 0x96, 0x29, 0x92, 0x2e, 0x94, 0x72, 0x23,
	0x8f, 0xdd, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x53, 0xd4, 0x06, 0x13, 0x30, 0x05, 0x00, 0x00,
}
