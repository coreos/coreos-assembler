// Documentation: https://github.com/coreos/coreos-ci/blob/main/README-upstream-ci.md

// Build coreos-assembler image and create
// an imageStream for it
def cpuCount = 6
def cpuCount_s = cpuCount.toString()

buildImageCustom(env: [ENABLE_GO_RACE_DETECTOR: "1", GOMAXPROCS: cpuCount_s], cpu: cpuCount_s)
def imageName = "coreos-ci-coreos-assembler-fec68d40-36f4-4f39-852e-cdd821074322"

def memory = (cpuCount * 1536) as Integer
pod(image: imageName + ":latest", kvm: true, cpu: "${cpuCount}", memory: "${memory}Mi") {
    checkout scm
    echo "ok"
}

def buildImageCustom(params = [:]) {
    def imageName
    def bcObj

    if (!params['env']) {
        params['env'] = []
    }

    openshift.withCluster() {
        openshift.withProject() {
            stage('CleanUp') {
            // Once we have the TTL controller enabled we can remove this stage
            // More: https://kubernetes.io/docs/concepts/workloads/controllers/ttlafterfinished/
                def jobs = openshift.selector("jobs").names()
                for (job in jobs) {
                    if (job.startsWith('job/coreos-ci')) {
                        def obj = openshift.selector(job).object()
                        if (obj.status.completionTime) {
                            openshift.selector(job).delete()
                        }
                    }
                }
            }
            stage('Prepare Env') {
                // TODO: Change buidlconfig to yaml and to use openshift.process
                // Issue described in:
                // https://github.com/coreos/coreos-ci-lib/pull/61#discussion_r569401940
                def bcJSON  = libraryResource 'com/github/coreos/buildconfig.json'
                def jobYaml = libraryResource 'com/github/coreos/job.yaml'
                def jobObj  = readYaml text: jobYaml
                bcObj       = readJSON text: bcJSON

                def UUID    = UUID.randomUUID()
                def scmVars = checkout scm
                def repo    = (scmVars.GIT_URL.substring(scmVars.GIT_URL.lastIndexOf('/') + 1)).replace('.git','')

                jobObj      = openshift.process(jobObj, "-p", "NAME=coreos-ci-$repo-${UUID}")
                def app     = openshift.create(jobObj)
                def job     = app.narrow('job')
                def jobMap  = job.object()
                def uid     = jobMap.metadata.get('uid')

                imageName = "coreos-ci-$repo-${UUID}".toString()

                //Create and unique name for image and bc
                bcObj['parameters'][0] +=['name': 'NAME', 'value': imageName]

                //Add OwnerReference for cascading deletion with the Job timeout
                bcObj['parameters'][3] +=['name': 'UID', 'value': "${uid}".toString()]
                bcObj['parameters'][2] +=['name': 'OWNERNAME', 'value': imageName]
                if (params['dockerFile']) {
                    bcObj['parameters'][1] +=['name': 'DOCKERFILE', 'value': "${params['dockerFile']}".toString()]
                }
                // these should check 'kind' instead of hardcoding 1
                params['env'].each{ name, val ->
                    bcObj['objects'][1]['spec']['strategy']['dockerStrategy']['env'] += ['name': name, 'value': val]
                }
                // initialize so we can populate it more easily
                bcObj['objects'][1]['spec']['resources'] = [requests: [:], limits: [:]]
                if (params['memory']) {
                    bcObj['objects'][1]['spec']['resources']['requests']['memory'] = params['memory'].toString()
                }
                if (params['cpu']) {
                    bcObj['objects'][1]['spec']['resources']['requests']['cpu'] = params['cpu'].toString()
                    // Also propagate CPU count to NCPUS, because it can be hard in a Kubernetes environment
                    // to determine how much CPU one should really use.
                    bcObj['objects'][1]['spec']['strategy']['dockerStrategy']['env'] += ['name': 'NCPUS', 'value': params['cpu'].toString()]
                }
            }
            stage('Create BuildConfig') {
                openshift.create(openshift.process(bcObj))
            }
            stage('Build') {
                echo "built"
                // shwrap("""
                //     touch dir.tar # pre-create it so the directory doesn't change when tar scans it
                //     tar --exclude dir.tar --exclude=./pod* -zcf dir.tar .
                // """)
                // def build = openshift.selector('bc', imageName).startBuild("--from-archive=dir.tar")
                // shwrap("rm dir.tar")

                // // Showing logs in Jenkins is also a way
                // // to wait for the build to finsih
                // build.logs('-f')
                // // Wait up to 2h for the build to finish
                // timeout(60*2) {
                //     build.untilEach(1) {
                //         def phase = it.object().status.phase
                //         if (phase in ["New", "Pending", "Running"]) {
                //             return false
                //         }
                //         if (phase != "Complete") {
                //             error("Error build image: status phase ${phase}")
                //         }
                //         return true
                //     }
                // }
           }
        }
    }
    return imageName.toString()
}
