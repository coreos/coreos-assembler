#!/usr/bin/env bash
set -euo pipefail

dn=$(dirname $0)
. ${dn}/cmdlib.sh

# Parse options
FORCE=
NORESUME=
options=$(getopt --options f --longoptions force,no-resume -- "$@")
[ $? -eq 0 ] || {
    print_help
    exit 1
}
eval set -- "$options"
while true; do
    case "$1" in
        -f | --force)
            FORCE="--force-nocache"
            ;;
        --no-resume)
            NORESUME="1"
            ;;
        --)
            shift
            break
            ;;
        *)
            fatal "$0: unrecognized option: $1"
            exit 1
            ;;
    esac
    shift
done

export LIBGUESTFS_BACKEND=direct

prepare_build

ostree --version
rpm-ostree --version

previous_build=
if [ -L ${workdir}/builds/latest ]; then
    previous_build=$(readlink ${workdir}/builds/latest)
    previous_builddir=${workdir}/builds/${previous_build}
    echo "Previous build: ${previous_build}"
fi

previous_commit=
if [ -n "${ref:-}" ]; then
    previous_commit=$(ostree --repo=${workdir}/repo rev-parse ${ref} || true)
fi
# If the ref was unset or missing, look at the previous build
if [ -z "${previous_commit}" ] && [ -n "${previous_build}" ]; then
    previous_commit=$(jq -r '.["ostree-commit"]' < "${previous_builddir}/meta.json")
fi
# Generate metadata that's *input* to the ostree commit
config_gitrev=$(cd ${configdir} && git describe --tags --always --abbrev=42)
config_dirty=false
if ! git -C ${configdir} diff --quiet --exit-code; then
    config_dirty=true
fi
commitmeta_input_json=$(pwd)/tmp/commit-metadata-input.json
cat >${commitmeta_input_json} <<EOF
{
  "coreos-assembler.config-gitrev": "${config_gitrev}",
  "coreos-assembler.config-dirty": ${config_dirty}
}
EOF
# These need to be absolute paths right now for rpm-ostree
composejson=$(pwd)/tmp/compose.json
# --cache-only is here since `fetch` is a separate verb.
runcompose --cache-only ${FORCE} --add-metadata-from-json ${commitmeta_input_json} \
           --write-composejson-to ${composejson}
# Very special handling for --write-composejson-to as rpm-ostree doesn't
# write it if the commit didn't change.
if [ -f "${changed_stamp}" ]; then
    commit=$(jq -r '.["ostree-commit"]' < "${composejson}")
    # Clean up prior versions
    rm -f ${workdir}/tmp/compose-*.json
    # Save this in case the image build fails
    cp -a --reflink=auto ${composejson} ${workdir}/tmp/compose-${commit}.json
else
    if [ -n "${NORESUME}" ]; then
        echo "--no-resume set, exiting"
        exit 0
    fi
    commit=${previous_commit}
    # Grab the previous JSON
    cp -a --reflink=auto ${workdir}/tmp/compose-${previous_commit}.json ${composejson}
fi
version=$(ostree --repo=${workdir}/repo-build show --print-metadata-key=version ${commit} | sed -e "s,',,g")
# https://github.com/ostreedev/ostree/issues/1562#issuecomment-385393872
# The passwd files (among others) don't have world readability.  This won't
# actually corrupt the repository as the *canonical* permissions are stored
# as xattrs.  Probably what we should do is have an ostree option to specify
# a permission mask for objects.
sudo chmod -R a+rX ${workdir}/repo-build/objects
ostree --repo=${workdir}/repo pull-local ${workdir}/repo-build "${ref:-${commit}}"
ostree --repo=${workdir}/repo summary -u

sha256sum_str() {
    sha256sum | cut -f 1 -d ' '
}

kickstart_input=${configdir}/image.ks
kickstart_checksum=$(cat ${kickstart_input} | sha256sum_str)
image_input_checksum=$((echo ${commit} && echo ${kickstart_checksum}) | sha256sum_str)

image_genver=1
if [ -n "${previous_build}" ]; then
    previous_image_input_checksum=$(jq -r '.["coreos-assembler.image-input-checksum"]' < "${previous_builddir}/meta.json")
    if [ "${image_input_checksum}" = "${previous_image_input_checksum}" ]; then
        echo "No changes in image inputs."
        exit 0
    fi
    previous_image_genver=$(jq -r '.["coreos-assembler.image-genver"]' < "${previous_builddir}/meta.json")
    if [ "${previous_commit}" = "${commit}" ]; then
        image_genver=$((${previous_image_genver} + 1))
    fi
fi

buildid=${version}-${image_genver}

# Generate JSON
if [ -n "${previous_commit}" ]; then
    previous_commit_json='"'"${previous_commit}"'"'
else
    previous_commit_json=null
fi

imageprefix=${name}-${version}-${image_genver}
# Make these two verbose
set -x
mkdir -p tmp/anaconda
/usr/lib/coreos-assembler/virt-install --dest=$(pwd)/tmp/${imageprefix}-base.qcow2 \
               --create-disk --kickstart ${kickstart_input} --kickstart-out $(pwd)/tmp/flattened.ks \
               --ostree-remote=${name} --ostree-stateroot=${name} \
               --ostree-ref=${ref:-${commit}} --ostree-repo=${workdir}/repo \
               --location ${workdir}/installer/*.iso --console-log-file $(pwd)/install.log \
               --logs $(pwd)/tmp/anaconda
/usr/lib/coreos-assembler/gf-oemid tmp/${imageprefix}-base.qcow2 $(pwd)/${imageprefix}-qemu.qcow2 qemu
set +x
# make a version-less symlink to have a stable path
ln -s ${imageprefix}-qemu.qcow2 ${name}-qemu.qcow2

cat > tmp/meta.json <<EOF
{
 "coreos-assembler.image-input-checksum": "${image_input_checksum}",
 "coreos-assembler.image-genver": "${image_genver}",
 "coreos-assembler.kickstart-checksum": "${kickstart_checksum}"
}
EOF
# Merge all the JSON
cat tmp/meta.json ${commitmeta_input_json} ${composejson} | jq -s add > meta.json

# Clean up our temporary data
rm tmp -rf
# Back to the toplevel build directory, so we can rename this one
cd ${workdir}/builds
# We create a .build-commit file to note that we're in the
# middle of a "commit".  This may be useful in the future
# for having things be transactional.  If for example we
# were interrupted between the rename() and linkat() below,
# things would be inconsistent and future builds would fail
# on the `mv`.
touch .build-commit
mv -T ${tmp_builddir} ${buildid}
# Replace the latest link
ln -Tsfr "${buildid}" latest
python3 -c 'import os,json,sys,stat;
builds=[]
for d in os.listdir("."):
  s = os.lstat(d)
  if not (stat.S_ISDIR(s.st_mode) and os.path.isfile(d + "/meta.json")):
    continue
  builds.append((d, s.st_ctime))
json.dump({"builds":
           list(map(lambda x: x[0], sorted(builds, key=lambda x: x[0])))},
          sys.stdout)
' > ${workdir}/tmp/builds.json
mv ${workdir}/tmp/builds.json builds.json
rm .build-commit
