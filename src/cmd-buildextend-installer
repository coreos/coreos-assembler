#!/usr/bin/env python3
# NOTE: PYTHONUNBUFFERED is set in cmdlib.sh for unbuffered output
#
# An operation that creates an ISO image for installing CoreOS

import argparse
import json
import os
import platform
import shutil
import sys
import tarfile
import tempfile

sys.path.insert(0, '/usr/lib/coreos-assembler')
from cmdlib import run_verbose, write_json, sha256sum_file

# Parse args and dispatch
parser = argparse.ArgumentParser()
parser.add_argument("--build", help="Build ID")
parser.add_argument("--force", action='store_true', default=False,
                    help="Overwrite previously generated installer")
args = parser.parse_args()

# default to latest build if not specified
if not args.build:
    with open('builds/builds.json') as f:
        j = json.load(f)
        args.build = j['builds'][0]

print(f"Targeting build: {args.build}")

workdir = os.path.abspath(os.getcwd())
builddir = os.path.join(workdir, 'builds', args.build)
buildmeta_path = os.path.join(builddir, 'meta.json')
with open(buildmeta_path) as f:
    buildmeta = json.load(f)

# Don't run if it's already been done, unless forced
if 'iso' in buildmeta['images'] and not args.force:
    print(f"Installer has already been built for {args.build}. Skipping.")
    print("You can force a rebuild with '--force'.")
    sys.exit(0)

base_name = buildmeta['name']
iso_name = f'{base_name}-{args.build}-installer.iso'
name_version = f'{base_name}-{args.build}'

tmpdir = os.environ.get("FORCE_TMPDIR", f"{workdir}/tmp/buildpost-installer")
if os.path.isdir(tmpdir):
    shutil.rmtree(tmpdir)

tmpisoroot = os.path.join(tmpdir, 'installer')
tmpisoimages = os.path.join(tmpisoroot, 'images')
tmpisoisolinux = os.path.join(tmpisoroot, 'isolinux')

os.mkdir(tmpdir)
os.mkdir(tmpisoroot)
os.mkdir(tmpisoimages)
os.mkdir(tmpisoisolinux)

def generate_iso():
    arch = platform.machine()

    if arch in ("s390", "s390x"):
        print(f"{arch} ISO generation is not supported at the moment")
        sys.exit(1)

    tmpisofile = os.path.join(tmpdir, iso_name)

    # Grab the commit hash for this build
    buildmeta_commit = buildmeta['ostree-commit']

    # Find the directory under `/usr/lib/modules/<kver>` where the
    # kernel/initrd live. It will be the 2nd entity output by
    # `ostree ls <commit> /usr/lib/modules`
    process = run_verbose(['/usr/bin/ostree', '--repo=./repo', 'ls',
                           '--nul-filenames-only', f"{buildmeta_commit}",
                           '/usr/lib/modules'], capture_output=True)
    moduledir = process.stdout.decode().split('\0')[1]

    # copy those files out of the ostree into the iso root dir
    for file in ['initramfs.img', 'vmlinuz']:
        run_verbose(['/usr/bin/ostree', '--repo=./repo', 'checkout',
                     '--user-mode', '--subpath', os.path.join(moduledir, file),
                     f"{buildmeta_commit}", tmpisoimages])
        # initramfs isn't world readable by default so let's open up perms
        os.chmod(os.path.join(tmpisoimages, file), 0o755)

    # TODO ignore EFI dir
    # Grab all the contents from the installer dir from the configs
    run_verbose(["rsync", "-av", "src/config/installer/", f"{tmpisoroot}/"])

    # These sections are based on lorax templates
    # see https://github.com/weldr/lorax/tree/master/share/templates.d/99-generic

    # Generate the ISO image. Lots of good info here:
    # https://fedoraproject.org/wiki/User:Pjones/BootableCDsForBIOSAndUEFI
    genisoargs = ['/usr/bin/genisoimage', '-verbose',
                  '-volset', f"{name_version}",
                  # For  greater portability, consider using both
                  # Joliet and Rock Ridge extensions. Umm, OK :)
                  '-rock', '-J', '-joliet-long']

    ### For x86_64 legacy boot (BIOS) booting
    if arch == "x86_64":
        # Install binaries from syslinux package
        isolinuxfiles = [('/usr/share/syslinux/isolinux.bin', 0o755),
                         ('/usr/share/syslinux/ldlinux.c32',  0o755),
                         ('/usr/share/syslinux/libcom32.c32', 0o755),
                         ('/usr/share/syslinux/libutil.c32',  0o755),
                         ('/usr/share/syslinux/vesamenu.c32', 0o755)]
        for src, mode in isolinuxfiles:
            dst = os.path.join(tmpisoisolinux, os.path.basename(src))
            shutil.copyfile(src, dst)
            os.chmod(dst, mode)

        # for legacy bios boot AKA eltorito boot
        genisoargs += ['-eltorito-boot', 'isolinux/isolinux.bin',
                       '-eltorito-catalog', 'isolinux/boot.cat',
                       '-no-emul-boot',
                       '-boot-load-size', '4',
                       '-boot-info-table']

    elif arch == "ppc64le":
        genisoargs += ['-r', '-l', '-sysid', 'PPC',
                       '-chrp-boot', '-graft-points']

    ### For x86_64 and aarch64 UEFI booting
    if arch in ("x86_64", "aarch64"):
        # Create the efiboot.img file. This is a fat32 formatted
        # filesystem that contains all the files needed for EFI boot
        # from an ISO.
        with tempfile.TemporaryDirectory() as tmpefidir:

            # In restrictive environments, setgid, setuid and ownership changes
            # may be restricted. This sets the file ownership to root and
            # removes the setgid and setuid bits in the tarball.
            def strip(tarinfo):
                tarinfo.uid = 0
                tarinfo.gid = 0
                if tarinfo.isdir():
                    tarinfo.mode = 0o755
                elif tarinfo.isfile():
                    tarinfo.mode = 0o0644
                return tarinfo

            # Install binaries from the grub2-efi and shim rpms (installed
            # in our COSA container). Manually construct the tarball to ensure
            # proper permissions and ownership
            efitarfile = tempfile.NamedTemporaryFile(suffix=".tar")
            with tarfile.open(efitarfile.name, "w:") as tar:
                tar.add('/boot/efi/EFI/', arcname="/EFI", filter=strip)
                tar.add('src/config/installer/EFI/', arcname='/EFI',
                        filter=strip)

            # Create the efiboot.img file (a fat filesystem) in the images/ dir
            # Note: virt-make-fs lets us do this as non-root
            efibootfile = os.path.join(tmpisoimages, 'efiboot.img')
            run_verbose(['virt-make-fs', '--type=vfat', efitarfile.name,
                         efibootfile])

        genisoargs += ['-eltorito-alt-boot',
                       '-efi-boot', 'images/efiboot.img',
                       '-no-emul-boot']

    # Define inputs and outputs
    genisoargs += ['-o', tmpisofile, tmpisoroot]

    run_verbose(genisoargs)

    kernel_name = f'{base_name}-{args.build}-installer-kernel'
    initramfs_name = f'{base_name}-{args.build}-installer-initramfs.img'
    kernel_file = os.path.join(builddir, kernel_name)
    initramfs_file = os.path.join(builddir, initramfs_name)
    shutil.copyfile(os.path.join(tmpisoimages, "vmlinuz"), kernel_file)
    shutil.copyfile(os.path.join(tmpisoimages, "initramfs.img"), initramfs_file)

    kernel_checksum = sha256sum_file(kernel_file)
    initramfs_checksum = sha256sum_file(initramfs_file)
    checksum = sha256sum_file(tmpisofile)

    buildmeta['images'].update({
        'iso': {
            'path': iso_name,
            'sha256': checksum
        },
        'kernel': {
            'path': kernel_name,
            'sha256': kernel_checksum
        },
        'initramfs': {
            'path': initramfs_name,
            'sha256': initramfs_checksum
        }
    })
    os.rename(tmpisofile, f"{builddir}/{iso_name}")
    write_json(buildmeta_path, buildmeta)
    print(f"Updated: {buildmeta_path}")


# Do it!
generate_iso()
