#!/usr/bin/env python3
# NOTE: PYTHONUNBUFFERED is set in cmdlib.sh for unbuffered output
#
# An operation that creates an ISO image for installing CoreOS

import argparse
import json
import os
import platform
import struct
import shutil
import sys
import tarfile
import tempfile

sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
from cmdlib import run_verbose, write_json, sha256sum_file
from cmdlib import import_ostree_commit

# Parse args and dispatch
parser = argparse.ArgumentParser()
parser.add_argument("--build", help="Build ID")
parser.add_argument("--force", action='store_true', default=False,
                    help="Overwrite previously generated installer")
args = parser.parse_args()

# default to latest build if not specified
if not args.build:
    with open('builds/builds.json') as f:
        j = json.load(f)
        args.build = j['builds'][0]

print(f"Targeting build: {args.build}")

workdir = os.path.abspath(os.getcwd())
builddir = os.path.join(workdir, 'builds', args.build)
buildmeta_path = os.path.join(builddir, 'meta.json')
with open(buildmeta_path) as f:
    buildmeta = json.load(f)

# Grab the commit hash for this build
buildmeta_commit = buildmeta['ostree-commit']

repo = os.path.join(workdir, 'tmp/repo')

# Don't run if it's already been done, unless forced
if 'iso' in buildmeta['images'] and not args.force:
    print(f"Installer has already been built for {args.build}. Skipping.")
    print("You can force a rebuild with '--force'.")
    sys.exit(0)

base_name = buildmeta['name']
iso_name = f'{base_name}-{args.build}-installer.iso'
name_version = f'{base_name}-{args.build}'

tmpdir = os.environ.get("FORCE_TMPDIR", f"{workdir}/tmp/buildpost-installer")
if os.path.isdir(tmpdir):
    shutil.rmtree(tmpdir)

tmpisoroot = os.path.join(tmpdir, 'installer')
tmpisoimages = os.path.join(tmpisoroot, 'images')
tmpisoisolinux = os.path.join(tmpisoroot, 'isolinux')

os.mkdir(tmpdir)
os.mkdir(tmpisoroot)
os.mkdir(tmpisoimages)
os.mkdir(tmpisoisolinux)

def generate_iso():
    arch = platform.machine()
    # convention for kernel and initramfs names
    kernel_img = 'vmlinuz'
    initramfs_img = 'initramfs.img'

    tmpisofile = os.path.join(tmpdir, iso_name)

    # Find the directory under `/usr/lib/modules/<kver>` where the
    # kernel/initrd live. It will be the 2nd entity output by
    # `ostree ls <commit> /usr/lib/modules`
    process = run_verbose(['/usr/bin/ostree', 'ls', '--repo', repo,
                           '--nul-filenames-only', f"{buildmeta_commit}",
                           '/usr/lib/modules'], capture_output=True)
    moduledir = process.stdout.decode().split('\0')[1]

    # copy those files out of the ostree into the iso root dir
    for file in [kernel_img, initramfs_img]:
        run_verbose(['/usr/bin/ostree', 'checkout', '--repo', repo,
                     '--user-mode', '--subpath', os.path.join(moduledir, file),
                     f"{buildmeta_commit}", tmpisoimages])
        # initramfs isn't world readable by default so let's open up perms
        os.chmod(os.path.join(tmpisoimages, file), 0o755)

    # TODO ignore EFI dir
    # Grab all the contents from the installer dir from the configs
    run_verbose(["rsync", "-av", "src/config/installer/", f"{tmpisoroot}/"])

    # These sections are based on lorax templates
    # see https://github.com/weldr/lorax/tree/master/share/templates.d/99-generic

    # Generate the ISO image. Lots of good info here:
    # https://fedoraproject.org/wiki/User:Pjones/BootableCDsForBIOSAndUEFI
    genisoargs = ['/usr/bin/genisoimage', '-verbose',
                  '-volset', f"{name_version}",
                  # For  greater portability, consider using both
                  # Joliet and Rock Ridge extensions. Umm, OK :)
                  '-rock', '-J', '-joliet-long']

    ### For x86_64 legacy boot (BIOS) booting
    if arch == "x86_64":
        # Install binaries from syslinux package
        isolinuxfiles = [('/usr/share/syslinux/isolinux.bin', 0o755),
                         ('/usr/share/syslinux/ldlinux.c32',  0o755),
                         ('/usr/share/syslinux/libcom32.c32', 0o755),
                         ('/usr/share/syslinux/libutil.c32',  0o755),
                         ('/usr/share/syslinux/vesamenu.c32', 0o755)]
        for src, mode in isolinuxfiles:
            dst = os.path.join(tmpisoisolinux, os.path.basename(src))
            shutil.copyfile(src, dst)
            os.chmod(dst, mode)

        # for legacy bios boot AKA eltorito boot
        genisoargs += ['-eltorito-boot', 'isolinux/isolinux.bin',
                       '-eltorito-catalog', 'isolinux/boot.cat',
                       '-no-emul-boot',
                       '-boot-load-size', '4',
                       '-boot-info-table']

    elif arch == "ppc64le":
        genisoargs += ['-r', '-l', '-sysid', 'PPC',
                       '-chrp-boot', '-graft-points']
    elif arch == "s390x":
        INITRD_ADDRESS = '0x02000000'
        lorax_templates = '/usr/share/lorax/templates.d/99-generic/config_files/s390'
        shutil.copy(os.path.join(lorax_templates, 'redhat.exec'), tmpisoimages)
        with open(os.path.join(lorax_templates, 'generic.ins'), 'r') as fp1:
            with open(os.path.join(tmpisoroot, 'generic.ins'), 'w') as fp2:
                [fp2.write(line.replace('@INITRD_LOAD_ADDRESS@', INITRD_ADDRESS)) for line in fp1]
        for prmfile in ['cdboot.prm', 'genericdvd.prm', 'generic.prm']:
            with open(os.path.join(tmpisoimages, prmfile), 'w') as fp1:
                line1 = 'cio_ignore=all,!condev rd.cmdline=ask'
                with open(os.path.join(tmpisoroot, 'zipl.prm'), 'r') as fp2:
                    line1 += ' ' + ' '.join([line2.strip('\n') for line2 in fp2])
                fp1.write(line1)

        # s390x's z/VM CMS files are limited to 8 char for filenames and extensions
        # Also it is nice to keep naming convetion with Fedora/RHEL for existing users and code
        shutil.move(os.path.join(tmpisoimages, kernel_img), os.path.join(tmpisoimages, 'kernel.img'))
        shutil.move(os.path.join(tmpisoimages, initramfs_img), os.path.join(tmpisoimages, 'initrd.img'))
        kernel_img = 'kernel.img'
        initramfs_img = 'initrd.img'

        # combine kernel, initramfs and cmdline using lorax/mk-s390-cdboot tool
        run_verbose(['/usr/bin/mk-s390-cdboot',
                     '-i', os.path.join(tmpisoimages, kernel_img),
                     '-r', os.path.join(tmpisoimages, initramfs_img),
                     '-p', os.path.join(tmpisoimages, 'cdboot.prm'),
                     '-o', os.path.join(tmpisoimages, 'cdboot.img')])
        # generate .addrsize file for LPAR
        with open(os.path.join(tmpisoimages, 'initrd.addrsize'), 'wb') as addrsize:
            addrsize_data = struct.pack(">iiii", 0, int(INITRD_ADDRESS, 16), 0,
                                        os.stat(os.path.join(tmpisoimages, initramfs_img)).st_size)
            addrsize.write(addrsize_data)

        # safely remove things we don't need in the final ISO tree
        for d in ['EFI', 'isolinux', 'zipl.prm']:
            run_verbose(['rm', '-rf', os.path.join(tmpisoroot, d)])

        genisoargs = ['/usr/bin/xorrisofs', '-verbose',
                      '-volset', f"{name_version}",
                      '-rational-rock', '-J', '-joliet-long',
                      '-no-emul-boot', '-eltorito-boot',
                      os.path.join(os.path.relpath(tmpisoimages, tmpisoroot), 'cdboot.img')]

    ### For x86_64 and aarch64 UEFI booting
    if arch in ("x86_64", "aarch64"):
        # Create the efiboot.img file. This is a fat32 formatted
        # filesystem that contains all the files needed for EFI boot
        # from an ISO.
        with tempfile.TemporaryDirectory() as tmpefidir:

            # In restrictive environments, setgid, setuid and ownership changes
            # may be restricted. This sets the file ownership to root and
            # removes the setgid and setuid bits in the tarball.
            def strip(tarinfo):
                tarinfo.uid = 0
                tarinfo.gid = 0
                if tarinfo.isdir():
                    tarinfo.mode = 0o755
                elif tarinfo.isfile():
                    tarinfo.mode = 0o0644
                return tarinfo

            tmpimageefidir = os.path.join(tmpdir, "efi")
            os.makedirs(tmpimageefidir)
            ostreeefidir="/usr/lib/ostree-boot/efi/EFI"

            # Fetch a list of folders in ostree EFI dir
            process = run_verbose(['/usr/bin/ostree', 'ls', '--repo', repo,
                                '--nul-filenames-only', f"{buildmeta_commit}",
                                ostreeefidir], capture_output=True)
            ostreeefidirfiles = process.stdout.decode().split('\0')[1:]
            ostreeefisubdirs = [x.replace(f"{ostreeefidir}/", '') for x in ostreeefidirfiles]

            for folder in ostreeefisubdirs:
                if not folder:
                    continue
                folderfullpath = os.path.join(ostreeefidir, folder)
                # copy files to a temporary directory
                destdir = os.path.join(tmpimageefidir, folder)
                run_verbose(['/usr/bin/ostree', 'checkout', '--repo', repo,
                            '--user-mode', '--subpath', folderfullpath,
                            f"{buildmeta_commit}", destdir])

            # Install binaries from boot partition and configs from installer/EFI
            # Manually construct the tarball to ensure proper permissions and ownership
            efitarfile = tempfile.NamedTemporaryFile(suffix=".tar")
            with tarfile.open(efitarfile.name, "w:", dereference=True) as tar:
                tar.add(tmpimageefidir, arcname="/EFI", filter=strip)
                tar.add('src/config/installer/EFI/', arcname='/EFI',
                        filter=strip)

            # Create the efiboot.img file (a fat filesystem) in the images/ dir
            # Note: virt-make-fs lets us do this as non-root
            efibootfile = os.path.join(tmpisoimages, 'efiboot.img')
            run_verbose(['virt-make-fs', '--type=vfat', efitarfile.name,
                         efibootfile])

        genisoargs += ['-eltorito-alt-boot',
                       '-efi-boot', 'images/efiboot.img',
                       '-no-emul-boot']

    # Define inputs and outputs
    genisoargs += ['-o', tmpisofile, tmpisoroot]

    run_verbose(genisoargs)

    kernel_name = f'{base_name}-{args.build}-installer-kernel'
    initramfs_name = f'{base_name}-{args.build}-installer-initramfs.img'
    kernel_file = os.path.join(builddir, kernel_name)
    initramfs_file = os.path.join(builddir, initramfs_name)
    shutil.copyfile(os.path.join(tmpisoimages, kernel_img), kernel_file)
    shutil.copyfile(os.path.join(tmpisoimages, initramfs_img), initramfs_file)

    kernel_checksum = sha256sum_file(kernel_file)
    initramfs_checksum = sha256sum_file(initramfs_file)
    checksum = sha256sum_file(tmpisofile)

    buildmeta['images'].update({
        'iso': {
            'path': iso_name,
            'sha256': checksum
        },
        'kernel': {
            'path': kernel_name,
            'sha256': kernel_checksum
        },
        'initramfs': {
            'path': initramfs_name,
            'sha256': initramfs_checksum
        }
    })
    os.rename(tmpisofile, f"{builddir}/{iso_name}")
    write_json(buildmeta_path, buildmeta)
    print(f"Updated: {buildmeta_path}")


commit_tar = os.path.join(builddir, 'ostree-commit.tar')
import_ostree_commit(repo, buildmeta_commit, commit_tar)

# Do it!
generate_iso()
