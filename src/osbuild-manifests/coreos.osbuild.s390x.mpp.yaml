version: '2'
mpp-vars:
  filename: $filename
  ostree_repo: $ostree_repo
  ostree_ref: $ostree_ref
  ociarchive: $ociarchive
  osname: $osname
  container_imgref: $container_imgref
  container_repo: $container_repo
  container_tag: $container_tag
  extra_kargs: $extra_kargs
  metal_image_size_mb: $metal_image_size_mb
  cloud_image_size_mb: $cloud_image_size_mb
  bios_boot_size_mb: 1
  ppc_prep_size_mb: 4
  reserved_part_size_mb: 1
  efi_system_size_mb: 127
  se_size_mb:   200
  boot_size_mb: 384
  boot_verity_size_mb: 128
  root_verity_size_mb: 256
  sector_size: 512
  four_k_sector_size: 4096
  # Filesystem UUID and label definitions. These UUIDs
  # are looked for on boot and if found replaced with
  # a new random UUID to make each install unique.
  sd_fs_label: se
  boot_fs_uuid: 96d15588-3596-4b3c-adca-a2ff7279ea63
  boot_fs_label: boot
  root_fs_uuid: 910678ff-f77e-4a7d-8d53-86f2ac47a823
  root_fs_label: root
  # Set the buildroot string to use for most operations here. We create
  # the buildroot from the target OSTree contents so we have version
  # matches. Unfortunately for FCOS there is no python so we can't
  # really use FCOS as the buildroot so we'll set it to "" so that
  # the host (COSA) gets used as the buildroot there.
  buildroot:
    mpp-if: osname in ['rhcos', 'scos']
    then: "name:build"
    else: ""
  # For the qemu stages we'll use the host buildroot (COSA)
  # because we definitely don't include qemu-img in CoreOS. ""
  # means to use the host as buildroot. It is worth noting that
  # the host buildroot is the default if nothing is specified.
  # We're still defining it here in an attempt to be explicit.
  qemu_stage_buildroot: ""
mpp-define-images:
  - id: image
    sector_size:
        mpp-format-int: "{sector_size}"
    size:
      mpp-format-string: "{metal_image_size_mb * 1024 * 1024}"
    table:
      uuid: 00000000-0000-4000-a000-000000000001
      label: gpt
      partitions:
        - name: boot
          type: 0FC63DAF-8483-4772-8E79-3D69D8477DE4
          size:
            mpp-format-int: "{boot_size_mb * 1024 * 1024 / sector_size}"
          partnum: 3
        - name: root
          type: 0FC63DAF-8483-4772-8E79-3D69D8477DE4
          partnum: 4
  - id: image4k
    sector_size:
        mpp-format-int: "{four_k_sector_size}"
    size:
      mpp-format-string: "{metal_image_size_mb * 1024 * 1024}"
    table:
      uuid: 00000000-0000-4000-a000-000000000001
      label: gpt
      partitions:
        - name: boot
          type: 0FC63DAF-8483-4772-8E79-3D69D8477DE4
          size:
            mpp-format-int: "{boot_size_mb * 1024 * 1024 / four_k_sector_size}"
          partnum: 3
        - name: root
          type: 0FC63DAF-8483-4772-8E79-3D69D8477DE4
          partnum: 4
pipelines:
  # If installing from container then let's pull the container file into a pipeline
  - name: oci-archive
    stages:
      - mpp-if: ociarchive != ''
        then:
          type: org.osbuild.copy
          inputs:
            inlinefile:
              type: org.osbuild.files
              origin: org.osbuild.source
              mpp-embed:
                id: coreos.ociarchive
                url:
                  mpp-format-string: 'file://{ociarchive}'
          options:
            paths:
              - from:
                  mpp-format-string: input://inlinefile/{embedded['coreos.ociarchive']}
                to: tree:///coreos.ociarchive
        else:
          type: org.osbuild.noop
  # Construct a buildroot here from the input container reference (either
  # ociarchive or registry/tag). Note that it won't actually be built
  # unless used somewhere later in the manifest.
  - name: build
    stages:
      - mpp-if: ociarchive != ''
        then:
          type: org.osbuild.container-deploy
          inputs:
            images:
              type: org.osbuild.containers
              origin: org.osbuild.pipeline
              references:
                name:oci-archive:
                  name: coreos.ociarchive
        else:
          type: org.osbuild.container-deploy
          inputs:
            images:
              type: org.osbuild.containers
              origin: org.osbuild.source
              mpp-resolve-images:
                images:
                  - source: $container_repo
                    tag: $container_tag
  - name: tree
    build:
      mpp-format-string: '{buildroot}'
    source-epoch: 1659397331
    stages:
      # Set the context of the root of the tree so that we avoid unlabeled_t files.
      # https://github.com/coreos/fedora-coreos-tracker/issues/1772
      - type: org.osbuild.selinux
        options:
          labels:
            /: system_u:object_r:root_t:s0
      - type: org.osbuild.ostree.init-fs
      - type: org.osbuild.ostree.os-init
        options:
          osname:
            mpp-format-string: '{osname}'
      - type: org.osbuild.ostree.config
        options:
          repo: /ostree/repo
          config:
            sysroot:
              readonly: true
              # on s390x 'none' for now, will set it to `zipl` in the later stage
              bootloader: none
             ## no grub_users="" on s390x
             #bls-append-except-default: grub_users=""
              # Opt-in to https://github.com/ostreedev/ostree/pull/2705 which will
              # add /boot as the prefix on top of BLS config entries. This is OK
              # because there is a symlink that is created in the root of the boot
              # filesystem by OSTree (boot -> .) that makes it so that /boot paths
              # will always work.
              bootprefix: true
      - type: org.osbuild.ignition
      # Deploy via OSTree repo if specified, otherwise ociarchive or container.
      - mpp-if: ostree_repo != ''
        then:
          type: org.osbuild.ostree.deploy
          options:
            osname:
              mpp-format-string: '{osname}'
            remote: fedora
            mounts:
              - /boot
            kernel_opts:
              - rw
             ## '$ignition_firstboot' only works with GRUB, not available on s390x
             #- '$ignition_firstboot'
              - mpp-format-string: '{extra_kargs}'
          inputs:
            commits:
              type: org.osbuild.ostree
              origin: org.osbuild.source
              mpp-resolve-ostree-commits:
                commits:
                  - ref: $ostree_ref
                    remote:
                      url: $ostree_repo
        else:
          mpp-if: ociarchive != ''
          then:
            type: org.osbuild.ostree.deploy.container
            options:
              osname:
                mpp-format-string: '{osname}'
              target_imgref:
                mpp-format-string: '{container_imgref}'
              mounts:
                - /boot
              kernel_opts:
                - rw
               ## '$ignition_firstboot' only works with GRUB, not available on s390x
               #- '$ignition_firstboot'
                - mpp-format-string: '{extra_kargs}'
            inputs:
              images:
                type: org.osbuild.containers
                origin: org.osbuild.pipeline
                references:
                  name:oci-archive:
                    name: coreos.ociarchive
          else:
            type: org.osbuild.ostree.deploy.container
            options:
              osname:
                mpp-format-string: '{osname}'
              target_imgref:
                mpp-format-string: '{container_imgref}'
              mounts:
                - /boot
              kernel_opts:
                - rw
               ## '$ignition_firstboot' only works with GRUB, not available on s390x
               #- '$ignition_firstboot'
                - mpp-format-string: '{extra_kargs}'
            inputs:
              images:
                type: org.osbuild.containers
                origin: org.osbuild.source
                mpp-resolve-images:
                  images:
                    - source: $container_repo
                      tag: $container_tag
      # Drop the immutable bit here (we add it back later) because it
      # causes failures when cleaning up tmp dirs.
      - type: org.osbuild.chattr
        options:
          items:
            tree:///:
              immutable: false
        mounts:
          - name: ostree.deployment
            type: org.osbuild.ostree.deployment
            options:
              deployment:
                default: true
      # On s390x set the bootloader to zipl. We need to do it here
      # rather than in the ostree.config stage above because we don't want
      # OSTree to invoke zipl during the deploy. It's done later in zipl.inst.
      - type: org.osbuild.ostree.config
        options:
          repo: /ostree/repo
          config:
            sysroot:
               bootloader: zipl
      - type: org.osbuild.ostree.aleph
        options:
          coreos_compat: true
          deployment:
            default: true
      - type: org.osbuild.ostree.selinux
        options:
          deployment:
            default: true
  - name: raw-image
    build:
      mpp-format-string: '{buildroot}'
    stages:
      - type: org.osbuild.truncate
        options:
          filename: disk.img
          size:
            mpp-format-string: '{image.size}'
      - type: org.osbuild.sfdisk
        devices:
          device:
            type: org.osbuild.loopback
            options:
              filename: disk.img
        options:
          mpp-format-json: '{image.layout}'
      - type: org.osbuild.mkfs.ext4
        devices:
          device:
            type: org.osbuild.loopback
            options:
              filename: disk.img
              start:
                mpp-format-int: '{image.layout[''boot''].start}'
              size:
                mpp-format-int: '{image.layout[''boot''].size}'
              lock: true
        options:
          uuid:
            mpp-format-string: '{boot_fs_uuid}'
          label:
            mpp-format-string: '{boot_fs_label}'
          # Set manually the metadata_csum_seed ext4 option otherwise changing the
          # filesystem UUID while it's mounted doesn't work. Can remove this when
          # metadata_csum_seed is default in RHEL, which can be checked by looking
          # in /etc/mke2fs.conf.
          metadata_csum_seed: true
      - type: org.osbuild.mkfs.xfs
        devices:
          device:
            type: org.osbuild.loopback
            options:
              filename: disk.img
              start:
                mpp-format-int: '{image.layout[''root''].start}'
              size:
                mpp-format-int: '{image.layout[''root''].size}'
              lock: true
        options:
          uuid:
            mpp-format-string: '{root_fs_uuid}'
          label:
            mpp-format-string: '{root_fs_label}'
      - type: org.osbuild.copy
        inputs:
          tree:
            type: org.osbuild.tree
            origin: org.osbuild.pipeline
            references:
              - name:tree
        options:
          paths:
            - from: input://tree/
              to: mount://root/
        devices:
          disk:
            type: org.osbuild.loopback
            options:
              filename: disk.img
              partscan: true
        mounts:
          - name: root
            type: org.osbuild.xfs
            source: disk
            partition:
              mpp-format-int: '{image.layout[''root''].partnum}'
            target: /
          - name: boot
            type: org.osbuild.ext4
            source: disk
            partition:
              mpp-format-int: '{image.layout[''boot''].partnum}'
            target: /boot
      - type: org.osbuild.chattr
        options:
          items:
            mount://root/:
              immutable: true
        devices:
          disk:
            type: org.osbuild.loopback
            options:
              filename: disk.img
              partscan: true
        mounts:
          - name: root
            type: org.osbuild.xfs
            source: disk
            partition:
              mpp-format-int: '{image.layout[''root''].partnum}'
            target: /
          - name: ostree.deployment
            type: org.osbuild.ostree.deployment
            options:
              source: mount
              deployment:
                default: true
  - name: raw-4k-image
    build:
      mpp-format-string: '{buildroot}'
    stages:
      - type: org.osbuild.truncate
        options:
          filename: disk.img
          size:
            mpp-format-string: '{image4k.size}'
      - type: org.osbuild.sfdisk
        devices:
          device:
            type: org.osbuild.loopback
            options:
              filename: disk.img
              sector-size:
                  mpp-format-int: "{four_k_sector_size}"
        options:
          mpp-format-json: '{image4k.layout}'
      - type: org.osbuild.mkfs.ext4
        devices:
          device:
            type: org.osbuild.loopback
            options:
              filename: disk.img
              start:
                mpp-format-int: '{image4k.layout[''boot''].start}'
              size:
                mpp-format-int: '{image4k.layout[''boot''].size}'
              lock: true
              sector-size:
                  mpp-format-int: "{four_k_sector_size}"
        options:
          uuid:
            mpp-format-string: '{boot_fs_uuid}'
          label:
            mpp-format-string: '{boot_fs_label}'
          # Set manually the metadata_csum_seed ext4 option otherwise changing the
          # filesystem UUID while it's mounted doesn't work. Can remove this when
          # metadata_csum_seed is default in RHEL, which can be checked by looking
          # in /etc/mke2fs.conf.
          metadata_csum_seed: true
      - type: org.osbuild.mkfs.xfs
        devices:
          device:
            type: org.osbuild.loopback
            options:
              filename: disk.img
              start:
                mpp-format-int: '{image4k.layout[''root''].start}'
              size:
                mpp-format-int: '{image4k.layout[''root''].size}'
              lock: true
              sector-size:
                  mpp-format-int: "{four_k_sector_size}"
        options:
          uuid:
            mpp-format-string: '{root_fs_uuid}'
          label:
            mpp-format-string: '{root_fs_label}'
      - type: org.osbuild.copy
        inputs:
          tree:
            type: org.osbuild.tree
            origin: org.osbuild.pipeline
            references:
              - name:tree
        options:
          paths:
            - from: input://tree/
              to: mount://root/
        devices:
          disk:
            type: org.osbuild.loopback
            options:
              filename: disk.img
              partscan: true
              sector-size:
                  mpp-format-int: "{four_k_sector_size}"
        mounts:
          - name: root
            type: org.osbuild.xfs
            source: disk
            partition:
              mpp-format-int: '{image4k.layout[''root''].partnum}'
            target: /
          - name: boot
            type: org.osbuild.ext4
            source: disk
            partition:
              mpp-format-int: '{image4k.layout[''boot''].partnum}'
            target: /boot
      - type: org.osbuild.chattr
        options:
          items:
            mount://root/:
              immutable: true
        devices:
          disk:
            type: org.osbuild.loopback
            options:
              filename: disk.img
              partscan: true
              sector-size:
                  mpp-format-int: "{four_k_sector_size}"
        mounts:
          - name: root
            type: org.osbuild.xfs
            source: disk
            partition:
              mpp-format-int: '{image4k.layout[''root''].partnum}'
            target: /
          - name: ostree.deployment
            type: org.osbuild.ostree.deployment
            options:
              source: mount
              deployment:
                default: true
  - mpp-import-pipelines:
      path: platform.metal.ipp.yaml
  - mpp-import-pipelines:
      path: platform.qemu.ipp.yaml
  - mpp-import-pipelines:
      path: platform.qemu-secex.ipp.yaml
