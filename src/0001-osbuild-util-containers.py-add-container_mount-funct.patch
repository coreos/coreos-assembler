From 701fa40dfce9a70c1dafdee32907a154463a1a44 Mon Sep 17 00:00:00 2001
From: Dusty Mabe <dusty@dustymabe.com>
Date: Thu, 9 Oct 2025 22:05:44 -0400
Subject: [PATCH 1/5] osbuild/util/containers.py: add container_mount()
 functionality

As prep for a later patch this moves the container image mounting code
from stages/org.osbuild.container-deploy into the containers library.

This commit also removes the associated unit test since it wasn't doing
much and also there doesn't seem to be a place for unit testing
osbuild/util/containers.py.
---
 osbuild/util/containers.py          | 42 ++++++++++++++++++++++++++-
 stages/org.osbuild.container-deploy | 45 ++---------------------------
 2 files changed, 43 insertions(+), 44 deletions(-)

diff --git a/osbuild/util/containers.py b/osbuild/util/containers.py
index 49eceee2..352c5c8e 100644
--- a/osbuild/util/containers.py
+++ b/osbuild/util/containers.py
@@ -1,8 +1,10 @@
 import json
 import os
+import random
+import string
 import subprocess
 import tempfile
-from contextlib import contextmanager
+from contextlib import ExitStack, contextmanager
 
 from osbuild.util.mnt import MountGuard, MountPermissions
 
@@ -184,3 +186,41 @@ def container_source(image):
     # that the inner ctx manager won't be cleaned up until the execution returns to this ctx manager.
     with container_source_fn(image, image_filepath, container_format) as image_source:
         yield image_name, image_source
+
+
+@contextmanager
+def container_mount(image, remove_signatures=False):
+    # Helper function for doing the `podman image mount`
+    @contextmanager
+    def _mount_container(image_tag):
+        cmd = ["podman", "image", "mount", image_tag],
+        result = subprocess.run(cmd, encoding="utf-8", check=False,
+                                stdout=subprocess.PIPE, stderr=subprocess.PIPE)
+        if result.returncode != 0:
+            code = result.returncode
+            msg = result.stderr.strip()
+            raise RuntimeError(f"Failed to mount image ({code}): {msg}")
+        try:
+            yield result.stdout.strip()
+        finally:
+            cmd = ["podman", "image", "umount", image_tag],
+            subprocess.run(cmd, check=True)
+
+    # We cannot use a tmpdir as storage here because of
+    # https://github.com/containers/storage/issues/1779 so instead
+    # just pick a random suffix. This runs inside bwrap which gives a
+    # tmp /var so it does not really matter much.
+    tmp_image_tag = "tmp-container-mount-" + "".join(random.choices(string.digits, k=14))
+    with container_source(image) as (_, source):
+        with ExitStack() as cm:
+            cm.callback(subprocess.run, ["podman", "rmi", tmp_image_tag], check=True)
+            # skopeo needs /var/tmp but the bwrap env is minimal and may not have it
+            os.makedirs("/var/tmp", mode=0o1777, exist_ok=True)
+            cmd = ["skopeo", "copy"]
+            if remove_signatures:
+                cmd.append("--remove-signatures")
+            cmd.extend([source, f"containers-storage:{tmp_image_tag}"])
+            subprocess.run(cmd, check=True)
+
+            with _mount_container(tmp_image_tag) as container_mountpoint:
+                yield container_mountpoint
diff --git a/stages/org.osbuild.container-deploy b/stages/org.osbuild.container-deploy
index 29fe7b97..f933ac73 100755
--- a/stages/org.osbuild.container-deploy
+++ b/stages/org.osbuild.container-deploy
@@ -1,8 +1,4 @@
 #!/usr/bin/python3
-import contextlib
-import os
-import random
-import string
 import subprocess
 import sys
 
@@ -10,51 +6,14 @@ import osbuild.api
 from osbuild.util import containers
 
 
-@contextlib.contextmanager
-def mount_container(image_tag):
-    result = subprocess.run(
-        ["podman", "image", "mount", image_tag],
-        stdout=subprocess.PIPE,
-        stderr=subprocess.PIPE,
-        encoding="utf-8",
-        check=False,
-    )
-    if result.returncode != 0:
-        code = result.returncode
-        msg = result.stderr.strip()
-        raise RuntimeError(f"Failed to mount image ({code}): {msg}")
-    try:
-        yield result.stdout.strip()
-    finally:
-        subprocess.run(
-            ["podman", "image", "umount", image_tag],
-            check=True,
-        )
-
-
 def main(inputs, tree, options):
     images = containers.parse_containers_input(inputs)
     assert len(images) == 1
     image = list(images.values())[0]
     remove_signatures = options.get("remove-signatures")
 
-    # skopeo needs /var/tmp but the bwrap env is minimal and may not have it
-    os.makedirs("/var/tmp", mode=0o1777, exist_ok=True)
-    # We cannot use a tmpdir as storage here because of
-    # https://github.com/containers/storage/issues/1779 so instead
-    # just pick a random suffix. This runs inside bwrap which gives a
-    # tmp /var so it does not really matter much.
-    image_tag = "tmp-container-deploy-" + "".join(random.choices(string.digits, k=14))
-    with contextlib.ExitStack() as cm:
-        cm.callback(subprocess.run, ["podman", "rmi", image_tag], check=True)
-        with containers.container_source(image) as (_, source):
-            cmd = ["skopeo", "copy"]
-            if remove_signatures:
-                cmd.append("--remove-signatures")
-            cmd.extend([source, f"containers-storage:{image_tag}"])
-            subprocess.run(cmd, check=True)
-        with mount_container(image_tag) as img:
-            subprocess.run(["cp", "-a", f"{img}/.", f"{tree}/"], check=True)
+    with containers.container_mount(image, remove_signatures) as container_mountpoint:
+        subprocess.run(["cp", "-a", f"{container_mountpoint}/.", f"{tree}/"], check=True)
     # postprocess the tree, would be nicer to filter before already
     for exclude in options.get("exclude", []):
         subprocess.run(["rm", "-rf", f"{tree}/{exclude}"], check=True)
-- 
2.51.0

