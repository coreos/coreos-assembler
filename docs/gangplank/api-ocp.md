<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# ocp

```go
import "github.com/coreos/gangplank/ocp"
```

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func GetClient(ctx ClusterContext) (*kubernetes.Clientset, string, error)](<#func-getclient>)
- [func clusterRunner(ctx ClusterContext, cp *cosaPod, envVars []v1.EnvVar) error](<#func-clusterrunner>)
- [func copyFile(src, dest string) error](<#func-copyfile>)
- [func cosaInit() error](<#func-cosainit>)
- [func decompress(in *os.File, dir string) error](<#func-decompress>)
- [func getPodIP(cs *kubernetes.Clientset, podNamespace, podName string) (string, error)](<#func-getpodip>)
- [func init()](<#func-init>)
- [func k8sInClusterClient() (*kubernetes.Clientset, string, error)](<#func-k8sinclusterclient>)
- [func kubernetesSecretsSetup(ac *kubernetes.Clientset, ns, toDir string) ([]string, error)](<#func-kubernetessecretssetup>)
- [func ocpBuildClient() error](<#func-ocpbuildclient>)
- [func podmanRunner(ctx ClusterContext, cp *cosaPod, envVars []v1.EnvVar) error](<#func-podmanrunner>)
- [func ptrBool(b bool) *bool](<#func-ptrbool>)
- [func ptrInt(i int64) *int64](<#func-ptrint>)
- [func ptrInt32(i int32) *int32](<#func-ptrint32>)
- [func randomString(n int) (string, error)](<#func-randomstring>)
- [func recieveInputBinary() (string, error)](<#func-recieveinputbinary>)
- [type Builder](<#type-builder>)
  - [func NewBuilder(ctx ClusterContext) (Builder, error)](<#func-newbuilder>)
- [type Cluster](<#type-cluster>)
  - [func GetCluster(ctx ClusterContext) (*Cluster, error)](<#func-getcluster>)
  - [func (c *Cluster) GetStdIO() (*os.File, *os.File, *os.File)](<#func-cluster-getstdio>)
  - [func (c *Cluster) SetPodman(srvDir string)](<#func-cluster-setpodman>)
  - [func (c *Cluster) SetStdIO(stdIn, stdOut, stdErr *os.File)](<#func-cluster-setstdio>)
  - [func (c *Cluster) toKubernetesCluster() *KubernetesCluster](<#func-cluster-tokubernetescluster>)
- [type ClusterContext](<#type-clustercontext>)
  - [func NewClusterContext(ctx context.Context, kc KubernetesCluster) ClusterContext](<#func-newclustercontext>)
- [type CosaPodder](<#type-cosapodder>)
  - [func NewCosaPodder(
    ctx ClusterContext,
    apiBuild *buildapiv1.Build,
    index int) (CosaPodder, error)](<#func-newcosapodder>)
- [type KubernetesCluster](<#type-kubernetescluster>)
  - [func NewCluster(inCluster bool, configFile string) KubernetesCluster](<#func-newcluster>)
- [type PodBuilder](<#type-podbuilder>)
  - [func NewPodBuilder(ctx ClusterContext, image, serviceAccount, jsF, workDir string) (PodBuilder, error)](<#func-newpodbuilder>)
- [type RemoteFile](<#type-remotefile>)
  - [func (r *RemoteFile) Extract(ctx context.Context, path string) error](<#func-remotefile-extract>)
  - [func (r *RemoteFile) WriteToPath(ctx context.Context, path string) error](<#func-remotefile-writetopath>)
- [type Return](<#type-return>)
  - [func (r *Return) Run(ctx context.Context) error](<#func-return-run>)
- [type Returner](<#type-returner>)
- [type SecretMapper](<#type-secretmapper>)
- [type buildConfig](<#type-buildconfig>)
  - [func newBC(ctx context.Context, c *Cluster) (*buildConfig, error)](<#func-newbc>)
  - [func (bc *buildConfig) Exec(ctx ClusterContext) error](<#func-buildconfig-exec>)
  - [func (bc *buildConfig) discoverStages(m *minioServer) ([]*RemoteFile, error)](<#func-buildconfig-discoverstages>)
  - [func (bc *buildConfig) ocpBinaryInput(m *minioServer) ([]*RemoteFile, error)](<#func-buildconfig-ocpbinaryinput>)
- [type byteFields](<#type-bytefields>)
- [type clusterCtxKey](<#type-clusterctxkey>)
- [type cosaPod](<#type-cosapod>)
  - [func (cp *cosaPod) WorkerRunner(ctx ClusterContext, envVars []v1.EnvVar) error](<#func-cosapod-workerrunner>)
  - [func (cp *cosaPod) addVolumeFromObjectLabel(obj metav1.Object, fields stringFields) error](<#func-cosapod-addvolumefromobjectlabel>)
  - [func (cp *cosaPod) addVolumesFromConfigMapLabels() error](<#func-cosapod-addvolumesfromconfigmaplabels>)
  - [func (cp *cosaPod) addVolumesFromSecretLabels() error](<#func-cosapod-addvolumesfromsecretlabels>)
  - [func (cp *cosaPod) getPodSpec(envVars []v1.EnvVar) *v1.Pod](<#func-cosapod-getpodspec>)
  - [func (cp *cosaPod) streamPodLogs(logging *bool, pod *v1.Pod, container string) error](<#func-cosapod-streampodlogs>)
- [type minioServer](<#type-minioserver>)
  - [func newMinioServer() *minioServer](<#func-newminioserver>)
  - [func (m *minioServer) client() (*minio.Client, error)](<#func-minioserver-client>)
  - [func (m *minioServer) ensureBucketExists(ctx context.Context, bucket string) error](<#func-minioserver-ensurebucketexists>)
  - [func (m *minioServer) fetcher(ctx context.Context, bucket, object string, dest io.Writer) error](<#func-minioserver-fetcher>)
  - [func (m *minioServer) kill()](<#func-minioserver-kill>)
  - [func (m *minioServer) putter(ctx context.Context, bucket, object, fpath string, overwrite bool) error](<#func-minioserver-putter>)
  - [func (m *minioServer) start(ctx context.Context) error](<#func-minioserver-start>)
- [type mountReferance](<#type-mountreferance>)
- [type outWriteCloser](<#type-outwritecloser>)
  - [func newNoopFileWriterCloser(f *os.File) *outWriteCloser](<#func-newnoopfilewritercloser>)
  - [func (o *outWriteCloser) Close() error](<#func-outwritecloser-close>)
- [type podBuild](<#type-podbuild>)
  - [func (pb *podBuild) Exec(ctx ClusterContext) error](<#func-podbuild-exec>)
  - [func (pb *podBuild) encodeAPIBuild() (string, error)](<#func-podbuild-encodeapibuild>)
  - [func (pb *podBuild) generateAPIBuild() error](<#func-podbuild-generateapibuild>)
  - [func (pb *podBuild) setInCluster() error](<#func-podbuild-setincluster>)
- [type secretMap](<#type-secretmap>)
  - [func getSecretMapping(s string) (*secretMap, bool)](<#func-getsecretmapping>)
  - [func (sm *secretMap) writeSecretEnvVars(d map[string][]byte, ret *[]string) error](<#func-secretmap-writesecretenvvars>)
  - [func (sm *secretMap) writeSecretFiles(toDir, name string, d map[string][]byte, ret *[]string) error](<#func-secretmap-writesecretfiles>)
- [type stringFields](<#type-stringfields>)
  - [func toStringFields(bf byteFields) stringFields](<#func-tostringfields>)
- [type varMap](<#type-varmap>)
- [type workSpec](<#type-workspec>)
  - [func newWorkSpec(ctx ClusterContext) (*workSpec, error)](<#func-newworkspec>)
  - [func (ws *workSpec) Exec(ctx ClusterContext) error](<#func-workspec-exec>)
  - [func (ws *workSpec) Marshal() ([]byte, error)](<#func-workspec-marshal>)
  - [func (ws *workSpec) Unmarshal(r io.Reader) error](<#func-workspec-unmarshal>)
  - [func (ws *workSpec) getEnvVars() ([]v1.EnvVar, error)](<#func-workspec-getenvvars>)


## Constants

```go
const (
    // ocpStructTag is the struct tag used to read in
    // OCPBuilder from envvars
    ocpStructTag = "envVar"

    // defaultContextdir is the default path to use for a build
    defaultContextDir = "/srv"

    // secretLabelName is the label to search for secrets to automatically use
    secretLabelName = "coreos-assembler.coreos.com/secret"
)
```

```go
const (
    kvmLabel       = "devices.kubevirt.io/kvm"
    localPodEnvVar = "COSA_FORCE_NO_CLUSTER"
)
```

```go
const (
    envVarSourceURI = "SOURCE_URI"
    envVarSourceRef = "SOURCE_REF"
)
```

```go
const (
    podBuildLabel      = "gangplank.coreos-assembler.coreos.com"
    podBuildAnnotation = podBuildLabel + "%s"
    podBuildRunnerTag  = "cosa-podBuild-runner"
)
```

```go
const (
    // sourceBin stores binary input
    sourceBin = "source.bin"

    // sourceSubPath is used when extracting binary inputs
    sourceSubPath = "source"
)
```

CosaWorkPodEnvVarName is the envVar used to identify WorkSpec json\.

```go
const CosaWorkPodEnvVarName = "COSA_WORK_POD_JSON"
```

```go
const (
    // MinioRegion is a "fake" region
    MinioRegion = "darkarts-1"
)
```

```go
const clusterNamespaceFile = "/var/run/secrets/kubernetes.io/serviceaccount/namespace"
```

secretMountRefLabel is used for mounting of secrets

```go
const mountRefLabel = "coreos-assembler.coreos.com/mount-ref"
```

## Variables

```go
var (
    // volumes are the volumes used in all pods created
    volumes = []v1.Volume{
        {
            Name: "srv",
            VolumeSource: v1.VolumeSource{
                EmptyDir: &v1.EmptyDirVolumeSource{
                    Medium: "",
                },
            },
        },
    }

    // volumeMounts are the common mounts used in all pods
    volumeMounts = []v1.VolumeMount{
        {
            Name:      "srv",
            MountPath: "/srv",
        },
    }

    // Define the Securite Contexts
    ocpSecContext = &v1.SecurityContext{}

    // On OpenShift 3.x, we require privileges.
    ocp3SecContext = &v1.SecurityContext{
        RunAsUser:  ptrInt(0),
        RunAsGroup: ptrInt(1000),
        Privileged: ptrBool(true),
    }

    // InitCommands to be run before work pod is executed.
    ocpInitCommand = []string{}

    // On OpenShift 3.x, /dev/kvm is unlikely to world RW. So we have to give ourselves
    // permission. Gangplank will run as root but `cosa` commands run as the builder
    // user. Note: on 4.x, gangplank will run unprivileged.
    ocp3InitCommand = []string{
        "/usr/bin/chmod 0666 /dev/kvm || echo missing kvm",
        "/usr/bin/stat /dev/kvm || :",
    }

    // Define the base requirements
    // cpu are in mils, memory is in mib
    baseCPU = *resource.NewQuantity(2, "")
    baseMem = *resource.NewQuantity(4*1024*1024*1024, resource.BinarySI)

    ocp3Requirements = v1.ResourceList{
        v1.ResourceCPU:    baseCPU,
        v1.ResourceMemory: baseMem,
    }

    ocpRequirements = v1.ResourceList{
        v1.ResourceCPU:    baseCPU,
        v1.ResourceMemory: baseMem,
        kvmLabel:          *resource.NewQuantity(1, ""),
    }
)
```

```go
var (
    // ErrNoSuchCloud is returned when the cloud is unknown
    ErrNoSuchCloud = errors.New("unknown cloud credential type")

    // ErrNoOCPBuildSpec is raised when no OCP envvars are found
    ErrNoOCPBuildSpec = errors.New("no OCP Build specification found")

    // ErrNotInCluster is used to singal that the host is not running in a
    // Kubernetes cluster
    ErrNotInCluster = errors.New("host is not in kubernetes cluster")

    // ErrInvalidOCPMode is used when there is no valid/supported mode the OCP
    // package. Currently this is thrown when neither a build client or kubernetes API
    // client can be initalized.
    ErrInvalidOCPMode = errors.New("program is not running as a buildconfig or with valid kubernetes service account")

    // ErrNoSourceInput is used to signal no source found.
    ErrNoSourceInput = errors.New("no source repo or binary payload defined")

    // ErrNotWorkPod is returned when the pod is not a work pod
    ErrNotWorkPod = errors.New("not a work pod")

    // ErrNoWorkFound is returned when the build client is neither a
    // workPod or BuildConfig.
    ErrNoWorkFound = errors.New("neither a buildconfig or workspec found")
)
```

```go
var (
    // These are used to parse the OpenShift API
    buildScheme       = runtime.NewScheme()
    buildCodecFactory = serializer.NewCodecFactory(buildScheme)
    buildJSONCodec    runtime.Codec

    // API Client for OpenShift builds.
    apiBuild *buildapiv1.Build
)
```

cosaSrvDir is where the build directory should be\. When the build API defines a contextDir then it will be used\. In most cases this should be /srv

```go
var cosaSrvDir = defaultContextDir
```

```go
var (
    // myHostName used for determining the hostname
    myHostName string
)
```

```go
var (
    // podmanCaps are the specific permissions we needed to run a podman
    // pod. This is a privileged pod.
    podmanCaps = []string{
        "CAP_DAC_READ_SEARCH",
        "CAP_LINUX_IMMUTABLE",
        "CAP_NET_BROADCAST",
        "CAP_NET_ADMIN",
        "CAP_IPC_LOCK",
        "CAP_IPC_OWNER",
        "CAP_SYS_MODULE",
        "CAP_SYS_RAWIO",
        "CAP_SYS_PTRACE",
        "CAP_SYS_PACCT",
        "CAP_SYS_ADMIN",
        "CAP_SYS_BOOT",
        "CAP_SYS_NICE",
        "CAP_SYS_RESOURCE",
        "CAP_SYS_TIME",
        "CAP_SYS_TTY_CONFIG",
        "CAP_LEASE",
        "CAP_AUDIT_CONTROL",
        "CAP_MAC_OVERRIDE",
        "CAP_MAC_ADMIN",
        "CAP_SYSLOG",
        "CAP_WAKE_ALARM",
        "CAP_BLOCK_SUSPEND",
        "CAP_AUDIT_READ",
    }
)
```

```go
var (
    // create the secret mappings for the supported Clouds
    secretMaps = []*secretMap{

        {
            label: "aliyun",
            fileVarMap: varMap{
                "config.json": "ALIYUN_CONFIG_FILE",
            },
        },

        {
            label: "aws",
            envVarMap: varMap{
                "aws_access_key_id":     "AWS_ACCESS_KEY_ID",
                "aws_secret_access_key": "AWS_SECRET_ACCESS_KEY",
                "aws_default_region":    "AWS_DEFAULT_REGION",
                "aws_ca_bundle":         "AWS_CA_BUNDLE",
            },
            fileVarMap: varMap{
                "config": "AWS_CONFIG_FILE",
            },
        },

        {
            label: "aws-cn",
            fileVarMap: varMap{
                "config": "AWS_CONFIG_FILE",
            },
        },

        {
            label: "azure",
            fileVarMap: varMap{
                "azure.json":        "AZURE_CONFIG",
                "azure.pem":         "AZURE_CERT_KEY",
                "azureProfile.json": "AZURE_PROFILE",
            },
        },

        {
            label: "gcp",
            fileVarMap: varMap{

                "gce.json": "GCP_IMAGE_UPLOAD_CONFIG",
                "gcp.json": "GCP_IMAGE_UPLOAD_CONFIG",
            },
        },

        {
            label: "internal-ca",
            fileVarMap: varMap{
                "ca.crt": "SSL_CERT_FILE",
            },
        },

        {
            label: "push-secret",
            fileVarMap: varMap{
                "docker.cfg": "PUSH_AUTH_JSON",
            },
        },

        {
            label: "pull-secret",
            fileVarMap: varMap{
                "docker.cfg": "PULL_AUTH_JSON",
            },
        },

        {
            label: "koji-keytab",
            fileVarMap: varMap{
                "keytab": "KOJI_KEYTAB",
            },
            envVarMap: varMap{
                "principal": "KOJI_PRINCIPAL",
            },
        },
    }
)
```

```go
var (
    volMaps = map[string]mountReferance{

        "internal-ca": {
            volumes: []v1.Volume{
                {
                    Name: "pki-trust",
                    VolumeSource: v1.VolumeSource{
                        EmptyDir: &v1.EmptyDirVolumeSource{
                            Medium: "",
                        },
                    },
                },
                {
                    Name: "pki",
                    VolumeSource: v1.VolumeSource{
                        Secret: &v1.SecretVolumeSource{
                            DefaultMode: ptrInt32(444),
                            SecretName:  "<UNSET>",
                        },
                    },
                },
            },
            volumeMounts: []v1.VolumeMount{
                {
                    Name:      "pki-trust",
                    MountPath: "/etc/pki/ca-trust/extracted",
                },
                {
                    Name:      "pki",
                    MountPath: "/etc/pki/ca-trust/source/anchors/",
                },
            },

            addInitCommands: []string{
                "mkdir -vp /etc/pki/ca-trust/extracted/{openssl,pem,java,edk2}",
                "update-ca-trust",
                "find /etc/pki/ca-trust/extracted",
            },
        },

        "docker.json": {
            volumes: []v1.Volume{
                {
                    Name: "docker.json",
                    VolumeSource: v1.VolumeSource{
                        Secret: &v1.SecretVolumeSource{
                            DefaultMode: ptrInt32(444),
                            SecretName:  "<UNSET>",
                        },
                    },
                },
            },
            volumeMounts: []v1.VolumeMount{
                {
                    Name:      "docker.json",
                    MountPath: filepath.Join(cosaSrvDir, "secrets", "auths"),
                },
            },
            requireData: []string{"docker.json"},
        },

        "koji-ca": {
            volumes: []v1.Volume{
                {
                    Name: "koji-ca",
                    VolumeSource: v1.VolumeSource{
                        ConfigMap: &v1.ConfigMapVolumeSource{
                            LocalObjectReference: v1.LocalObjectReference{
                                Name: "<UNSET>",
                            },
                        },
                    },
                },
            },
            volumeMounts: []v1.VolumeMount{
                {
                    Name:      "koji-ca",
                    MountPath: "/etc/pki/brew",
                },
            },
        },

        "koji-config": {
            volumes: []v1.Volume{
                {
                    Name: "koji-config",
                    VolumeSource: v1.VolumeSource{
                        ConfigMap: &v1.ConfigMapVolumeSource{
                            LocalObjectReference: v1.LocalObjectReference{
                                Name: "<UNSET>",
                            },
                        },
                    },
                },
            },
            volumeMounts: []v1.VolumeMount{
                {
                    Name:      "koji-config",
                    MountPath: "/etc/koji.conf.d",
                },
            },
        },

        "krb5.conf": {
            volumes: []v1.Volume{
                {
                    Name: "koji-kerberos",
                    VolumeSource: v1.VolumeSource{
                        ConfigMap: &v1.ConfigMapVolumeSource{
                            LocalObjectReference: v1.LocalObjectReference{
                                Name: "<UNSET>",
                            },
                        },
                    },
                },
            },
            volumeMounts: []v1.VolumeMount{
                {
                    Name:      "koji-kerberos",
                    MountPath: "/etc/krb5.conf.d",
                },
            },
        },
    }
)
```

## func GetClient

```go
func GetClient(ctx ClusterContext) (*kubernetes.Clientset, string, error)
```

GetClient fetches the Kubernetes Client from a ClusterContext\.

## func clusterRunner

```go
func clusterRunner(ctx ClusterContext, cp *cosaPod, envVars []v1.EnvVar) error
```

clusterRunner creates an OpenShift/Kubernetes pod for the work to be done\. The output of the pod is streamed and captured on the console\.

## func copyFile

```go
func copyFile(src, dest string) error
```

## func cosaInit

```go
func cosaInit() error
```

cosaInit does the initial COSA setup\. To support both pod and buildConfig based builds\, first check the API client\, then check envVars\. The use of envVars in this case is \*safe\*; \`SOURCE\_\{URI\,REF\} == apiBuild\.Spec\.Source\.Git\.\{URI\,REF\}\`\. That is\, SOURCE\_\* envVars will always match the apiBuild\.Spec\.Source\.Git\.\* values\.

## func decompress

```go
func decompress(in *os.File, dir string) error
```

decompress takes an open file and extracts its to directory\.

## func getPodIP

```go
func getPodIP(cs *kubernetes.Clientset, podNamespace, podName string) (string, error)
```

getPodIP returns the IP of a pod\. getPodIP blocks pending until the podIP is recieved\.

## func init

```go
func init()
```

## func k8sInClusterClient

```go
func k8sInClusterClient() (*kubernetes.Clientset, string, error)
```

k8sInClusterClient opens an in\-cluster Kubernetes API client\. The running pod must have a service account defined in the PodSpec\.

## func kubernetesSecretsSetup

```go
func kubernetesSecretsSetup(ac *kubernetes.Clientset, ns, toDir string) ([]string, error)
```

kubernetesSecretSetup looks for matching secrets in the environment matching 'coreos\-assembler\.coreos\.com/secret=k' and then maps the secret automatically in\. "k" must be in the "known" secrets type to be mapped automatically\.

## func ocpBuildClient

```go
func ocpBuildClient() error
```

ocpBuildClient initalizes the OpenShift Build Client API\.

## func podmanRunner

```go
func podmanRunner(ctx ClusterContext, cp *cosaPod, envVars []v1.EnvVar) error
```

podmanRunner runs the work in a Podman container using workDir as \`/srv\` \`podman kube play\` does not work well due to permission mappings; there is no way to do id mappings\.

## func ptrBool

```go
func ptrBool(b bool) *bool
```

## func ptrInt

```go
func ptrInt(i int64) *int64
```

## func ptrInt32

```go
func ptrInt32(i int32) *int32
```

ptrInt32 converts an int32 to a ptr of the int32

## func randomString

```go
func randomString(n int) (string, error)
```

## func recieveInputBinary

```go
func recieveInputBinary() (string, error)
```

extractInputBinary processes the provided input stream as directed by BinaryBuildSource into dir\. OpenShift sends binary builds over stdin\. To make our life easier\, use the OpenShift API to process the input\. Returns the name of the file written\.

## type Builder

Builder implements the Build

```go
type Builder interface {
    Exec(ctx ClusterContext) error
}
```

```go
var (
    // srvBucket is the name of the bucket to use for remote
    // files being served up
    srvBucket = "source"

    // buildConfig is a builder.
    _   Builder = &buildConfig{}
)
```

workSpec is a Builder\.

```go
var _ Builder = &workSpec{}
```

### func NewBuilder

```go
func NewBuilder(ctx ClusterContext) (Builder, error)
```

NewBuilder returns a Builder\. NewBuilder determines what "Builder" to return by first trying Worker and then an OpenShift builder\.

## type Cluster

Cluster describes a Kubnetenes Cluster\.

```go
type Cluster struct {
    cs         *kubernetes.Clientset
    nameSpace  string
    configFile string

    // inCluster indicates the client should use the Kubernetes in-cluster client
    inCluster bool

    // podman indicates that the container should be built using Podman
    podman bool

    // podmanSrvDir is the scratch workdir for podman and is bind-mounted
    // in as /srv.
    podmanSrvDir string

    stdIn  *os.File
    stdOut *os.File
    stdErr *os.File
}
```

### func GetCluster

```go
func GetCluster(ctx ClusterContext) (*Cluster, error)
```

GetCluster fetches the Cluster options from the Context

### func \(\*Cluster\) GetStdIO

```go
func (c *Cluster) GetStdIO() (*os.File, *os.File, *os.File)
```

GetStdIO returns the stdIO options

### func \(\*Cluster\) SetPodman

```go
func (c *Cluster) SetPodman(srvDir string)
```

SetPodman forces out\-of\-cluster execution via Podman\.

### func \(\*Cluster\) SetStdIO

```go
func (c *Cluster) SetStdIO(stdIn, stdOut, stdErr *os.File)
```

SetStdIO sets the IO options TODO: Implement for \`cosa remote\`

### func \(\*Cluster\) toKubernetesCluster

```go
func (c *Cluster) toKubernetesCluster() *KubernetesCluster
```

toKubernetesCluster casts the cluster to the interface

## type ClusterContext

ClusterContext is a context

```go
type ClusterContext context.Context
```

### func NewClusterContext

```go
func NewClusterContext(ctx context.Context, kc KubernetesCluster) ClusterContext
```

NewClusterContext context with cluster options\.

## type CosaPodder

CosaPodder create COSA capable pods\.

```go
type CosaPodder interface {
    WorkerRunner(ctx ClusterContext, envVar []v1.EnvVar) error
}
```

a cosaPod is a CosaPodder

```go
var _ CosaPodder = &cosaPod{}
```

### func NewCosaPodder

```go
func NewCosaPodder(
    ctx ClusterContext,
    apiBuild *buildapiv1.Build,
    index int) (CosaPodder, error)
```

NewCosaPodder creates a CosaPodder

## type KubernetesCluster

KubernetesCluster is the Gangplank interface to using a cluster\.

```go
type KubernetesCluster interface {
    SetStdIO(stdIn, stdOut, stdErr *os.File)
    GetStdIO() (*os.File, *os.File, *os.File)
    SetPodman(string)
}
```

Cluster implements a KubernetesCluster

```go
var _ KubernetesCluster = &Cluster{}
```

### func NewCluster

```go
func NewCluster(inCluster bool, configFile string) KubernetesCluster
```

NewCluster returns a Kubernetes cluster

## type PodBuilder

PodBuilder is the manual/unbounded Build interface\. A PodBuilder uses a build\.openshift\.io/v1 Build interface to use the exact same code path between the two\.

```go
type PodBuilder interface {
    Exec(ctx ClusterContext) error
}
```

cli is a Builder \(and a poor one at that too\.\.\.\) While a ClusterPodBuilder is a Builder\, we treat it seperately\.

```go
var _ PodBuilder = &podBuild{}
```

### func NewPodBuilder

```go
func NewPodBuilder(ctx ClusterContext, image, serviceAccount, jsF, workDir string) (PodBuilder, error)
```

NewPodBuilder returns a ClusterPodBuilder ready for execution\.

## type RemoteFile

RemoteFile is an object to fetch from a remote server

```go
type RemoteFile struct {
    Bucket     string         `json:"bucket,omitempty"`
    Object     string         `json:"object,omitempty"`
    Minio      *minioServer   `json:"remote,omitempty"`
    Compressed bool           `json:"comptempty"`
    Artifact   *cosa.Artifact `json:"artifact,omitempty"`
}
```

### func \(\*RemoteFile\) Extract

```go
func (r *RemoteFile) Extract(ctx context.Context, path string) error
```

Extract decompresses the remote file to the path\.

### func \(\*RemoteFile\) WriteToPath

```go
func (r *RemoteFile) WriteToPath(ctx context.Context, path string) error
```

WriteToPath fetches the remote file and writes it locally\.

## type Return

Return describes the location of where to send results\.

```go
type Return struct {
    Minio     *minioServer `json:"remote"`
    Bucket    string       `json:"bucket"`
    Overwrite bool         `json:"overwrite"`

    // ArtifactTypes will return only artifacts that known and defined
    // For example []string{"aws","azure"}
    ArtifactTypes []string `json:"artifacts"`

    // Return all files found in the builds directory
    All bool `json:"all"`
}
```

### func \(\*Return\) Run

```go
func (r *Return) Run(ctx context.Context) error
```

Run executes the report by walking the build path\.

## type Returner

Returner sends the results to the ReportServer

```go
type Returner interface {
    Run(ctx context.Context) error
}
```

Return is a Returner

```go
var _ Returner = &Return{}
```

## type SecretMapper

SecretMapper maps a secretMap

```go
type SecretMapper interface {
    Setup() error
}
```

## type buildConfig

buildConfig represent the input into a buildConfig\.

```go
type buildConfig struct {
    JobSpecURL  string `envVar:"COSA_JOBSPEC_URL"`
    JobSpecRef  string `envVar:"COSA_JOBSPEC_REF"`
    JobSpecFile string `envVar:"COSA_JOBSPEC_FILE"`
    CosaCmds    string `envVar:"COSA_CMDS"`

    // Information about the parent pod
    PodName      string `envVar:"COSA_POD_NAME"`
    PodIP        string `envVar:"COSA_POD_IP"`
    PodNameSpace string `envVar:"COSA_POD_NAMESPACE"`

    // HostIP is the kubernetes IP address of the running pod.
    HostIP  string
    HostPod string

    // Internal copy of the JobSpec
    JobSpec spec.JobSpec

    ClusterCtx ClusterContext
}
```

### func newBC

```go
func newBC(ctx context.Context, c *Cluster) (*buildConfig, error)
```

newBC accepts a context and returns a buildConfig

### func \(\*buildConfig\) Exec

```go
func (bc *buildConfig) Exec(ctx ClusterContext) error
```

Exec executes the command using the closure for the commands

### func \(\*buildConfig\) discoverStages

```go
func (bc *buildConfig) discoverStages(m *minioServer) ([]*RemoteFile, error)
```

discoverStages supports the envVar and \*\.cosa\.sh scripts as implied stages\. The envVar stage will be run first\, followed by the \`\*\.cosa\.sh\` scripts\.

### func \(\*buildConfig\) ocpBinaryInput

```go
func (bc *buildConfig) ocpBinaryInput(m *minioServer) ([]*RemoteFile, error)
```

ocpBinaryInput decompresses the binary input\. If the binary input is a tarball with an embedded JobSpec\, its extracted\, read and used\.

## type byteFields

byteField represents a configMap's data fields

```go
type byteFields map[string][]byte
```

## type clusterCtxKey

```go
type clusterCtxKey int
```

```go
const clusterObj clusterCtxKey = 0
```

## type cosaPod

cosaPod is a COSA pod

```go
type cosaPod struct {
    apiBuild   *buildapiv1.Build
    clusterCtx ClusterContext

    ocpInitCommand  []string
    ocpRequirements v1.ResourceList
    ocpSecContext   *v1.SecurityContext
    volumes         []v1.Volume
    volumeMounts    []v1.VolumeMount

    index int
    pod   *v1.Pod
}
```

### func \(\*cosaPod\) WorkerRunner

```go
func (cp *cosaPod) WorkerRunner(ctx ClusterContext, envVars []v1.EnvVar) error
```

WorkerRunner runs a worker pod on either OpenShift/Kubernetes or in as a podman container\.

### func \(\*cosaPod\) addVolumeFromObjectLabel

```go
func (cp *cosaPod) addVolumeFromObjectLabel(obj metav1.Object, fields stringFields) error
```

addVolumeFromObjectLabel is a helper that recieves an object and data and looks up the object's name from volMaps\. If a mapping is found\, then the object is added to cosaPod's definition\.

### func \(\*cosaPod\) addVolumesFromConfigMapLabels

```go
func (cp *cosaPod) addVolumesFromConfigMapLabels() error
```

addVolumesFromConfigMapLabels discovers configMaps with matching labels and if known\, adds the defined volume mount from volMaps\.

### func \(\*cosaPod\) addVolumesFromSecretLabels

```go
func (cp *cosaPod) addVolumesFromSecretLabels() error
```

addVolumesFromSecretLabels discovers secrets with matching labels and if known\, adds the defined volume mount from volMaps\.

### func \(\*cosaPod\) getPodSpec

```go
func (cp *cosaPod) getPodSpec(envVars []v1.EnvVar) *v1.Pod
```

getPodSpec returns a pod specification\.

### func \(\*cosaPod\) streamPodLogs

```go
func (cp *cosaPod) streamPodLogs(logging *bool, pod *v1.Pod, container string) error
```

streamPodLogs steams the pod's logs to logging and to disk\. Worker pods are responsible for their work\, but not for their logs\. To make streamPodLogs thread safe and non\-blocking\, it expects a pointer to a bool\. If that pointer is nil or true\, then we return\.

## type minioServer

minioServer describes a Minio S3 Object stoarge to start\.

```go
type minioServer struct {
    AccessKey    string `json:"accesskey"`
    SecretKey    string `json:"secretkey"`
    Host         string `json:"host"`
    Port         int    `json:"port"`
    dir          string
    minioOptions minio.Options
    cmd          *exec.Cmd
}
```

### func newMinioServer

```go
func newMinioServer() *minioServer
```

newMinioSever defines an ephemeral minio config\. To prevent random pods/people accessing or relying on the server\, we use entirely random keys\.

### func \(\*minioServer\) client

```go
func (m *minioServer) client() (*minio.Client, error)
```

GetClient returns a Minio Client

### func \(\*minioServer\) ensureBucketExists

```go
func (m *minioServer) ensureBucketExists(ctx context.Context, bucket string) error
```

### func \(\*minioServer\) fetcher

```go
func (m *minioServer) fetcher(ctx context.Context, bucket, object string, dest io.Writer) error
```

fetcher retrieves an object from a Minio server

### func \(\*minioServer\) kill

```go
func (m *minioServer) kill()
```

kill terminates the minio server\.

### func \(\*minioServer\) putter

```go
func (m *minioServer) putter(ctx context.Context, bucket, object, fpath string, overwrite bool) error
```

putter uploads the contents of an io\.Reader to a remote MinioServer

### func \(\*minioServer\) start

```go
func (m *minioServer) start(ctx context.Context) error
```

start a MinioServer based on the configuration\.

## type mountReferance

mountReferance is mapping of secrets or a configmap

```go
type mountReferance struct {
    volumes         []v1.Volume
    volumeMounts    []v1.VolumeMount
    requireData     []string
    addInitCommands []string
}
```

## type outWriteCloser

outWriteCloser is a noop closer

```go
type outWriteCloser struct {
    *os.File
}
```

### func newNoopFileWriterCloser

```go
func newNoopFileWriterCloser(f *os.File) *outWriteCloser
```

### func \(\*outWriteCloser\) Close

```go
func (o *outWriteCloser) Close() error
```

## type podBuild

```go
type podBuild struct {
    apibuild *buildapiv1.Build
    bc       *buildConfig
    js       *spec.JobSpec

    clusterCtx ClusterContext
    pod        *v1.Pod

    hostname         string
    image            string
    ipaddr           string
    jobSpecFile      string
    projectNamespace string
    serviceAccount   string
    workDir          string
}
```

### func \(\*podBuild\) Exec

```go
func (pb *podBuild) Exec(ctx ClusterContext) error
```

Exec starts the unbounded build\.

### func \(\*podBuild\) encodeAPIBuild

```go
func (pb *podBuild) encodeAPIBuild() (string, error)
```

encodeAPIBuilder the ci buildapiv1 object to a JSON object\. JSON is the messaginging interface for Kubernetes\.

### func \(\*podBuild\) generateAPIBuild

```go
func (pb *podBuild) generateAPIBuild() error
```

generateAPIBuild creates a "mock" buildconfig\.openshift\.io/v1 Kubernetes object that is consumed by \`bc\.go\`\.

### func \(\*podBuild\) setInCluster

```go
func (pb *podBuild) setInCluster() error
```

setInCluster does the nessasary setup for unbounded builder running as an in\-cluster build\.

## type secretMap

```go
type secretMap struct {
    label      string
    envVarMap  varMap
    fileVarMap varMap
}
```

### func getSecretMapping

```go
func getSecretMapping(s string) (*secretMap, bool)
```

Get SecretMapping returns the secretMap and true if found\.

### func \(\*secretMap\) writeSecretEnvVars

```go
func (sm *secretMap) writeSecretEnvVars(d map[string][]byte, ret *[]string) error
```

writeSecretEnvVars creates envVars\.

### func \(\*secretMap\) writeSecretFiles

```go
func (sm *secretMap) writeSecretFiles(toDir, name string, d map[string][]byte, ret *[]string) error
```

writeSecretFiles writes secrets to their location based on the map\.

## type stringFields

stringFields represent a secret's data fields

```go
type stringFields map[string]string
```

### func toStringFields

```go
func toStringFields(bf byteFields) stringFields
```

toStringFields is used to convert from a byteFields to a stringFields

## type varMap

```go
type varMap map[string]string
```

## type workSpec

workSpec define job for remote worker to do A workSpec is dispatched by a builder and is tightly coupled to to the dispatching pod\.

```go
type workSpec struct {
    RemoteFiles   []*RemoteFile     `json:"remotefiles"`
    JobSpec       spec.JobSpec      `json:"jobspec"`
    ExecuteStages []string          `json:"executeStages"`
    APIBuild      *buildapiv1.Build `json:"apiBuild"`
    Return        *Return           `json:"return"`
}
```

### func newWorkSpec

```go
func newWorkSpec(ctx ClusterContext) (*workSpec, error)
```

newWorkSpec returns a workspec from the environment

### func \(\*workSpec\) Exec

```go
func (ws *workSpec) Exec(ctx ClusterContext) error
```

Exec executes the work spec tasks\.

### func \(\*workSpec\) Marshal

```go
func (ws *workSpec) Marshal() ([]byte, error)
```

Marshal returns the JSON of a WorkSpec\.

### func \(\*workSpec\) Unmarshal

```go
func (ws *workSpec) Unmarshal(r io.Reader) error
```

Unmarshal decodes an io\.Reader to a workSpec\.

### func \(\*workSpec\) getEnvVars

```go
func (ws *workSpec) getEnvVars() ([]v1.EnvVar, error)
```

getEnvVars returns the envVars to be exposed to the worker pod\. When \`newWorkSpec\` is called\, the envVar will read the embedded string JSON and the worker will get its configuration\.



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
