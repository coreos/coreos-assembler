<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# ocp

```go
import "github.com/coreos/gangplank/ocp"
```

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func GetClient(ctx ClusterContext) (*kubernetes.Clientset, string, error)](<#func-getclient>)
- [func checkPort(port int) error](<#func-checkport>)
- [func clusterRunner(term termChan, cp CosaPodder, envVars []v1.EnvVar) error](<#func-clusterrunner>)
- [func copyFile(src, dest string) error](<#func-copyfile>)
- [func cosaInit() error](<#func-cosainit>)
- [func decompress(in io.ReadCloser, dir string) error](<#func-decompress>)
- [func getHostname() string](<#func-gethostname>)
- [func getLocalFileStamp(path string) (int64, error)](<#func-getlocalfilestamp>)
- [func getNetIP() (string, error)](<#func-getnetip>)
- [func getPodIP(cs *kubernetes.Clientset, podNamespace, podName string) (string, error)](<#func-getpodip>)
- [func getPortOrNext(port int) int](<#func-getportornext>)
- [func getPushTagless(s string) (string, string)](<#func-getpushtagless>)
- [func init()](<#func-init>)
- [func isKnownBuildMeta(n string) bool](<#func-isknownbuildmeta>)
- [func k8sInClusterClient() (*kubernetes.Clientset, string, error)](<#func-k8sinclusterclient>)
- [func kubernetesSecretsSetup(ac *kubernetes.Clientset, ns, toDir string) ([]string, error)](<#func-kubernetessecretssetup>)
- [func mustHaveImage(ctx context.Context, image string) error](<#func-musthaveimage>)
- [func newFileStamp() string](<#func-newfilestamp>)
- [func ocpBuildClient() error](<#func-ocpbuildclient>)
- [func podmanRunner(term termChan, cp CosaPodder, envVars []v1.EnvVar) error](<#func-podmanrunner>)
- [func ptrBool(b bool) *bool](<#func-ptrbool>)
- [func ptrInt(i int64) *int64](<#func-ptrint>)
- [func ptrInt32(i int32) *int32](<#func-ptrint32>)
- [func pushOstreeToRegistry(ctx ClusterContext, push *spec.Registry, build *cosa.Build) error](<#func-pushostreetoregistry>)
- [func randomString(n int) (string, error)](<#func-randomstring>)
- [func recieveInputBinary() (string, error)](<#func-recieveinputbinary>)
- [func sshForwarder(ctx context.Context, cfg *SSHForwardPort) (chan<- bool, error)](<#func-sshforwarder>)
- [func streamPodLogs(client *kubernetes.Clientset, namespace string, pod *v1.Pod, term termChan) error](<#func-streampodlogs>)
- [func tokenRegistryLogin(ctx ClusterContext, tlsVerify *bool, registry string) error](<#func-tokenregistrylogin>)
- [func uploadCustomBuildContainer(ctx ClusterContext, tlsVerify *bool, apiBuild *buildapiv1.Build, build *cosa.Build) error](<#func-uploadcustombuildcontainer>)
- [func uploadPathAsTarBall(ctx context.Context, bucket, object, path, workDir string, sudo bool, r *Return) error](<#func-uploadpathastarball>)
- [func writeDockerSecret(ctx ClusterContext, clusterSecretName, authPath string) error](<#func-writedockersecret>)
- [func writeToWriters(l *log.Entry, in io.ReadCloser, outs ...io.Writer) <-chan error](<#func-writetowriters>)
- [type Builder](<#type-builder>)
  - [func NewBuilder(ctx ClusterContext) (Builder, error)](<#func-newbuilder>)
- [type Cluster](<#type-cluster>)
  - [func GetCluster(ctx ClusterContext) (*Cluster, error)](<#func-getcluster>)
  - [func (c *Cluster) GetStdIO() (*os.File, *os.File, *os.File)](<#func-cluster-getstdio>)
  - [func (c *Cluster) SetPodman(srvDir string)](<#func-cluster-setpodman>)
  - [func (c *Cluster) SetRemoteCluster(kubeConfig, namespace string)](<#func-cluster-setremotecluster>)
  - [func (c *Cluster) SetStdIO(stdIn, stdOut, stdErr *os.File)](<#func-cluster-setstdio>)
  - [func (c *Cluster) toKubernetesCluster() *KubernetesCluster](<#func-cluster-tokubernetescluster>)
- [type ClusterContext](<#type-clustercontext>)
  - [func NewClusterContext(ctx context.Context, kc KubernetesCluster) ClusterContext](<#func-newclustercontext>)
- [type CosaPodder](<#type-cosapodder>)
  - [func NewCosaPodder(
    ctx ClusterContext,
    apiBuild *buildapiv1.Build,
    index int) (CosaPodder, error)](<#func-newcosapodder>)
  - [func NewHopPod(ctx ClusterContext, image, serviceAccount, workDir string, js *spec.JobSpec) CosaPodder](<#func-newhoppod>)
- [type KubernetesCluster](<#type-kubernetescluster>)
  - [func NewCluster(inCluster bool) KubernetesCluster](<#func-newcluster>)
- [type PodBuilder](<#type-podbuilder>)
  - [func NewPodBuilder(ctx ClusterContext, image, serviceAccount, workDir string, js *spec.JobSpec) (PodBuilder, error)](<#func-newpodbuilder>)
- [type RemoteFile](<#type-remotefile>)
  - [func getBuildMeta(jsonPath, keyPathBase string, m *minioServer, l *log.Entry) []*RemoteFile](<#func-getbuildmeta>)
  - [func getStageFiles(buildID string,
    l *log.Entry, m *minioServer, lastBuild *cosa.Build, s *spec.Stage) (*cosa.Build, []*RemoteFile, error)](<#func-getstagefiles>)
  - [func (r *RemoteFile) Extract(ctx context.Context, path string) error](<#func-remotefile-extract>)
  - [func (r *RemoteFile) WriteToPath(ctx context.Context, path string) error](<#func-remotefile-writetopath>)
- [type Return](<#type-return>)
  - [func (r *Return) Run(ctx context.Context, ws *workSpec) error](<#func-return-run>)
- [type Returner](<#type-returner>)
- [type SSHForwardPort](<#type-sshforwardport>)
  - [func getSshMinioForwarder(j *spec.JobSpec) *SSHForwardPort](<#func-getsshminioforwarder>)
- [type SecretMapper](<#type-secretmapper>)
- [type buildConfig](<#type-buildconfig>)
  - [func newBC(ctx context.Context, c *Cluster) (*buildConfig, error)](<#func-newbc>)
  - [func (bc *buildConfig) Exec(ctx ClusterContext) (err error)](<#func-buildconfig-exec>)
  - [func (bc *buildConfig) discoverStages(m *minioServer) ([]*RemoteFile, error)](<#func-buildconfig-discoverstages>)
  - [func (bc *buildConfig) ocpBinaryInput(m *minioServer) ([]*RemoteFile, error)](<#func-buildconfig-ocpbinaryinput>)
- [type byteFields](<#type-bytefields>)
- [type clusterCtxKey](<#type-clusterctxkey>)
- [type consoleLogWriter](<#type-consolelogwriter>)
  - [func newConsoleLogWriter(prefix string) *consoleLogWriter](<#func-newconsolelogwriter>)
  - [func (cw *consoleLogWriter) Write(b []byte) (int, error)](<#func-consolelogwriter-write>)
- [type cosaPod](<#type-cosapod>)
  - [func (cp *cosaPod) GetClusterCtx() ClusterContext](<#func-cosapod-getclusterctx>)
  - [func (cp *cosaPod) WorkerRunner(term termChan, envVars []v1.EnvVar) error](<#func-cosapod-workerrunner>)
  - [func (cp *cosaPod) addVolumeFromObjectLabel(obj metav1.Object, fields stringFields) error](<#func-cosapod-addvolumefromobjectlabel>)
  - [func (cp *cosaPod) addVolumesFromConfigMapLabels() error](<#func-cosapod-addvolumesfromconfigmaplabels>)
  - [func (cp *cosaPod) addVolumesFromSecretLabels() error](<#func-cosapod-addvolumesfromsecretlabels>)
  - [func (cp *cosaPod) getPodSpec(envVars []v1.EnvVar) (*v1.Pod, error)](<#func-cosapod-getpodspec>)
- [type hopPod](<#type-hoppod>)
  - [func (h *hopPod) GetClusterCtx() ClusterContext](<#func-hoppod-getclusterctx>)
  - [func (h *hopPod) WorkerRunner(term termChan, _ []v1.EnvVar) error](<#func-hoppod-workerrunner>)
  - [func (h *hopPod) getPodSpec([]v1.EnvVar) (*v1.Pod, error)](<#func-hoppod-getpodspec>)
- [type minioServer](<#type-minioserver>)
  - [func StartStandaloneMinioServer(ctx context.Context, srvDir, cfgFile string, overSSH *SSHForwardPort) (*minioServer, error)](<#func-startstandaloneminioserver>)
  - [func minioCfgFromFile(f string) (mk minioServer, err error)](<#func-miniocfgfromfile>)
  - [func minioCfgReader(in io.Reader) (m minioServer, err error)](<#func-miniocfgreader>)
  - [func newMinioServer(cfgFile string) *minioServer](<#func-newminioserver>)
  - [func (m *minioServer) Exists(bucket, object string) bool](<#func-minioserver-exists>)
  - [func (m *minioServer) Kill()](<#func-minioserver-kill>)
  - [func (m *minioServer) Wait()](<#func-minioserver-wait>)
  - [func (m *minioServer) WriteJSON(w io.Writer) error](<#func-minioserver-writejson>)
  - [func (m *minioServer) WriteToFile(f string) error](<#func-minioserver-writetofile>)
  - [func (m *minioServer) client() (*minio.Client, error)](<#func-minioserver-client>)
  - [func (m *minioServer) ensureBucketExists(ctx context.Context, bucket string) error](<#func-minioserver-ensurebucketexists>)
  - [func (m *minioServer) exec(ctx context.Context) error](<#func-minioserver-exec>)
  - [func (m *minioServer) fetcher(ctx context.Context, bucket, object string, dest io.Writer) error](<#func-minioserver-fetcher>)
  - [func (m *minioServer) getStamp(bucket, object string) (int64, error)](<#func-minioserver-getstamp>)
  - [func (m *minioServer) isLocalNewer(bucket, object string, path string) (bool, error)](<#func-minioserver-islocalnewer>)
  - [func (m *minioServer) putter(ctx context.Context, bucket, object, fpath string) error](<#func-minioserver-putter>)
  - [func (m *minioServer) stampFile(bucket, object string) error](<#func-minioserver-stampfile>)
  - [func (m *minioServer) start(ctx context.Context) error](<#func-minioserver-start>)
- [type mountReferance](<#type-mountreferance>)
- [type outWriteCloser](<#type-outwritecloser>)
  - [func newNoopFileWriterCloser(f *os.File) *outWriteCloser](<#func-newnoopfilewritercloser>)
  - [func (o *outWriteCloser) Close() error](<#func-outwritecloser-close>)
- [type podBuild](<#type-podbuild>)
  - [func (pb *podBuild) Exec(ctx ClusterContext) error](<#func-podbuild-exec>)
  - [func (pb *podBuild) encodeAPIBuild() (string, error)](<#func-podbuild-encodeapibuild>)
  - [func (pb *podBuild) generateAPIBuild() error](<#func-podbuild-generateapibuild>)
  - [func (pb *podBuild) setInCluster() error](<#func-podbuild-setincluster>)
- [type podmanRunnerFunc](<#type-podmanrunnerfunc>)
- [type secretMap](<#type-secretmap>)
  - [func getSecretMapping(s string) (*secretMap, bool)](<#func-getsecretmapping>)
  - [func (sm *secretMap) writeSecretEnvVars(d map[string][]byte, ret *[]string) error](<#func-secretmap-writesecretenvvars>)
  - [func (sm *secretMap) writeSecretFiles(toDir, name string, d map[string][]byte, ret *[]string) error](<#func-secretmap-writesecretfiles>)
- [type stringFields](<#type-stringfields>)
  - [func toStringFields(bf byteFields) stringFields](<#func-tostringfields>)
- [type termChan](<#type-termchan>)
- [type varMap](<#type-varmap>)
- [type workSpec](<#type-workspec>)
  - [func newWorkSpec(ctx ClusterContext) (*workSpec, error)](<#func-newworkspec>)
  - [func (ws *workSpec) Exec(ctx ClusterContext) error](<#func-workspec-exec>)
  - [func (ws *workSpec) Marshal() ([]byte, error)](<#func-workspec-marshal>)
  - [func (ws *workSpec) Unmarshal(r io.Reader) error](<#func-workspec-unmarshal>)
  - [func (ws *workSpec) getEnvVars() ([]v1.EnvVar, error)](<#func-workspec-getenvvars>)


## Constants

```go
const (
    // ocpStructTag is the struct tag used to read in
    // OCPBuilder from envvars
    ocpStructTag = "envVar"

    // defaultContextdir is the default path to use for a build
    defaultContextDir = "/srv"

    // secretLabelName is the label to search for secrets to automatically use
    secretLabelName = "coreos-assembler.coreos.com/secret"

    // cosaSrvCache is the location of the cache files
    cosaSrvCache = "/srv/cache"

    // cosaSrvTmpRepo is the location the repo files
    cosaSrvTmpRepo = "/srv/tmp/repo"

    // cacheTarballName is the name of the file used when Stage.{Require,Return}Cache is true
    cacheTarballName = "cache.tar.gz"

    // cacheRepoTarballName is the name of the file used when Stage.{Require,Return}RepoCache is true
    cacheRepoTarballName = "repo.tar.gz"

    // cacheBucket is used for storing the cache
    cacheBucket = "cache"
)
```

```go
const (
    kvmLabel       = "devices.kubevirt.io/kvm"
    localPodEnvVar = "COSA_FORCE_NO_CLUSTER"
)
```

```go
const (
    envVarSourceURI = "SOURCE_URI"
    envVarSourceRef = "SOURCE_REF"
)
```

```go
const (
    clusterNamespaceFile    = "/var/run/secrets/kubernetes.io/serviceaccount/namespace"
    serviceAccountTokenFile = "/var/run/secrets/kubernetes.io/serviceaccount/token"
)
```

```go
const (
    podBuildLabel      = "gangplank.coreos-assembler.coreos.com"
    podBuildAnnotation = podBuildLabel + "-%s"
    podBuildRunnerTag  = "cosa-podBuild-runner"
)
```

```go
const (
    // sourceBin stores binary input
    sourceBin = "source.bin"

    // sourceSubPath is used when extracting binary inputs
    sourceSubPath = "source"
)
```

CosaWorkPodEnvVarName is the envVar used to identify WorkSpec json\.

```go
const CosaWorkPodEnvVarName = "COSA_WORK_POD_JSON"
```

```go
const fileStampName = "gangplank.coreos.com/cosa/stamp"
```

secretMountRefLabel is used for mounting of secrets

```go
const mountRefLabel = "coreos-assembler.coreos.com/mount-ref"
```

podmanContainerHostEnvVar is used by both Gangplank and the podman API to decide if the execution of the pod should happen over SSH\.

```go
const podmanContainerHostEnvVar = "CONTAINER_HOST"
```

## Variables

```go
var (
    gangwayCmd = "/usr/bin/gangway"

    // volumes are the volumes used in all pods created
    volumes = []v1.Volume{
        {
            Name: "srv",
            VolumeSource: v1.VolumeSource{
                EmptyDir: &v1.EmptyDirVolumeSource{
                    Medium: "",
                },
            },
        },
        {
            Name: "pki-trust",
            VolumeSource: v1.VolumeSource{
                EmptyDir: &v1.EmptyDirVolumeSource{
                    Medium: "",
                },
            },
        },
        {
            Name: "pki-anchors",
            VolumeSource: v1.VolumeSource{
                EmptyDir: &v1.EmptyDirVolumeSource{
                    Medium: "",
                },
            },
        },
        {
            Name: "container-certs",
            VolumeSource: v1.VolumeSource{
                EmptyDir: &v1.EmptyDirVolumeSource{
                    Medium: "",
                },
            },
        },
    }

    // volumeMounts are the common mounts used in all pods
    volumeMounts = []v1.VolumeMount{
        {
            Name:      "srv",
            MountPath: "/srv",
        },
        {
            Name:      "pki-trust",
            MountPath: "/etc/pki/ca-trust/extracted",
        },
        {
            Name:      "pki-anchors",
            MountPath: "/etc/pki/ca-trust/anchors",
        },
        {
            Name:      "container-certs",
            MountPath: "/etc/containers/cert.d",
        },
    }

    // Define basic envVars
    ocpEnvVars = []v1.EnvVar{
        {

            Name:  "SSL_CERT_FILE",
            Value: "/etc/containers/cert.d/ca.crt",
        },
        {
            Name:  "OSCONTAINER_CERT_DIR",
            Value: "/etc/containers/cert.d",
        },
    }

    // Define the Securite Contexts
    ocpSecContext = &v1.SecurityContext{}

    // On OpenShift 3.x, we require privileges.
    ocp3SecContext = &v1.SecurityContext{
        RunAsUser:  ptrInt(0),
        RunAsGroup: ptrInt(1000),
        Privileged: ptrBool(true),
    }

    // InitCommands to be run before work in pod is executed.
    ocpInitCommand = []string{
        "mkdir -vp /etc/pki/ca-trust/extracted/{openssl,pem,java,edk2}",

        "cp -av /etc/pki/ca-trust/source/anchors2/*{crt,pem} /etc/pki/ca-trust/anchors/ || :",

        "cp -av /run/secrets/kubernetes.io/serviceaccount/ca.crt /etc/pki/ca-trust/anchors/cluster-ca.crt || :",
        "cp -av /run/secrets/kubernetes.io/serviceaccount/service-ca.crt /etc/pki/ca-trust/anchors/service-ca.crt || :",

        "update-ca-trust",

        "mkdir -vp /etc/containers/certs.d",
        "cat /run/secrets/kubernetes.io/serviceaccount/*crt >> /etc/containers/certs.d/ca.crt || :",
        "cat /etc/pki/ca-trust/extracted/pem/* >> /etc/containers/certs.d/ca.crt ||:",
    }

    // On OpenShift 3.x, /dev/kvm is unlikely to world RW. So we have to give ourselves
    // permission. Gangplank will run as root but `cosa` commands run as the builder
    // user. Note: on 4.x, gangplank will run unprivileged.
    ocp3InitCommand = append(ocpInitCommand,
        "/usr/bin/chmod 0666 /dev/kvm || echo missing kvm",
        "/usr/bin/stat /dev/kvm || :",
    )

    // Define the base requirements
    // cpu are in mils, memory is in mib
    baseCPU = *resource.NewQuantity(2, "")
    baseMem = *resource.NewQuantity(4*1024*1024*1024, resource.BinarySI)

    ocp3Requirements = v1.ResourceList{
        v1.ResourceCPU:    baseCPU,
        v1.ResourceMemory: baseMem,
    }

    ocpRequirements = v1.ResourceList{
        v1.ResourceCPU:    baseCPU,
        v1.ResourceMemory: baseMem,
        kvmLabel:          *resource.NewQuantity(1, ""),
    }
)
```

```go
var (
    // ErrNoSuchCloud is returned when the cloud is unknown
    ErrNoSuchCloud = errors.New("unknown cloud credential type")

    // ErrNoOCPBuildSpec is raised when no OCP envvars are found
    ErrNoOCPBuildSpec = errors.New("no OCP Build specification found")

    // ErrNotInCluster is used to singal that the host is not running in a
    // Kubernetes cluster
    ErrNotInCluster = errors.New("host is not in kubernetes cluster")

    // ErrInvalidOCPMode is used when there is no valid/supported mode the OCP
    // package. Currently this is thrown when neither a build client or kubernetes API
    // client can be initalized.
    ErrInvalidOCPMode = errors.New("program is not running as a buildconfig or with valid kubernetes service account")

    // ErrNoSourceInput is used to signal no source found.
    ErrNoSourceInput = errors.New("no source repo or binary payload defined")

    // ErrNotWorkPod is returned when the pod is not a work pod
    ErrNotWorkPod = errors.New("not a work pod")

    // ErrNoWorkFound is returned when the build client is neither a
    // workPod or BuildConfig.
    ErrNoWorkFound = errors.New("neither a buildconfig or workspec found")
)
```

```go
var (
    // These are used to parse the OpenShift API
    buildScheme       = runtime.NewScheme()
    buildCodecFactory = serializer.NewCodecFactory(buildScheme)
    buildJSONCodec    runtime.Codec

    // API Client for OpenShift builds.
    apiBuild *buildapiv1.Build
)
```

```go
var (
    // sudoBashCmd is used for shelling out to comamnds.
    sudoBashCmd = []string{"sudo", "bash", "-c"}

    // bashCmd is used for shelling out to commands
    bashCmd = []string{"bash", "-c"}
)
```

consoleLogWriter is an io\.Writer\.

```go
var _ io.Writer = &consoleLogWriter{}
```

decompress is a spec TarDecompressorFunc

```go
var _ spec.TarDecompressorFunc = decompress
```

cosaSrvDir is where the build directory should be\. When the build API defines a contextDir then it will be used\. In most cases this should be /srv

```go
var cosaSrvDir = defaultContextDir
```

podTimeOut is the lenght of time to wait for a pod to complete its work\.

```go
var podTimeOut = 90 * time.Minute
```

```go
var (
    // podmanCaps are the specific permissions we needed to run a podman
    // pod. This is a privileged pod.
    podmanCaps = []string{
        "CAP_DAC_READ_SEARCH",
        "CAP_LINUX_IMMUTABLE",
        "CAP_NET_BROADCAST",
        "CAP_NET_ADMIN",
        "CAP_IPC_LOCK",
        "CAP_IPC_OWNER",
        "CAP_SYS_MODULE",
        "CAP_SYS_RAWIO",
        "CAP_SYS_PTRACE",
        "CAP_SYS_PACCT",
        "CAP_SYS_ADMIN",
        "CAP_SYS_BOOT",
        "CAP_SYS_NICE",
        "CAP_SYS_RESOURCE",
        "CAP_SYS_TIME",
        "CAP_SYS_TTY_CONFIG",
        "CAP_LEASE",
        "CAP_AUDIT_CONTROL",
        "CAP_MAC_OVERRIDE",
        "CAP_MAC_ADMIN",
        "CAP_SYSLOG",
        "CAP_WAKE_ALARM",
        "CAP_BLOCK_SUSPEND",
        "CAP_AUDIT_READ",
    }
)
```

```go
var (
    // create the secret mappings for the supported Clouds
    secretMaps = []*secretMap{

        {
            label: "aliyun",
            fileVarMap: varMap{
                "config.json": "ALIYUN_CONFIG_FILE",
            },
        },

        {
            label: "aws",
            envVarMap: varMap{
                "aws_access_key_id":     "AWS_ACCESS_KEY_ID",
                "aws_secret_access_key": "AWS_SECRET_ACCESS_KEY",
                "aws_default_region":    "AWS_DEFAULT_REGION",
                "aws_ca_bundle":         "AWS_CA_BUNDLE",
            },
            fileVarMap: varMap{
                "config": "AWS_CONFIG_FILE",
            },
        },

        {
            label: "aws-cn",
            fileVarMap: varMap{
                "config": "AWS_CN_CONFIG_FILE",
            },
        },

        {
            label: "azure",
            fileVarMap: varMap{
                "azure.json":        "AZURE_CONFIG",
                "azure.pem":         "AZURE_CERT_KEY",
                "azureProfile.json": "AZURE_PROFILE",
            },
        },

        {
            label: "gcp",
            fileVarMap: varMap{

                "gce.json": "GCP_IMAGE_UPLOAD_CONFIG",
                "gcp.json": "GCP_IMAGE_UPLOAD_CONFIG",
            },
        },

        {
            label: "internal-ca",
            fileVarMap: varMap{
                "ca.crt": "SSL_CERT_FILE",
            },
        },

        {
            label: "push-secret",
            fileVarMap: varMap{
                "docker.cfg": "PUSH_AUTH_JSON",
            },
        },

        {
            label: "pull-secret",
            fileVarMap: varMap{
                "docker.cfg": "PULL_AUTH_JSON",
            },
        },

        {
            label: "koji-keytab",
            fileVarMap: varMap{
                "keytab": "KOJI_KEYTAB",
            },
            envVarMap: varMap{
                "principal": "KOJI_PRINCIPAL",
            },
        },
    }
)
```

srvBucket is the name of the bucket to use for remote files being served up

```go
var srvBucket = "source"
```

stageDependencyTimeOut is the length of time to wait for a stage's dependencies\.

```go
var stageDependencyTimeOut = 1 * time.Hour
```

```go
var (
    volMaps = map[string]mountReferance{

        "internal-ca": {
            volumes: []v1.Volume{
                {
                    Name: "pki",
                    VolumeSource: v1.VolumeSource{
                        Secret: &v1.SecretVolumeSource{
                            DefaultMode: ptrInt32(444),
                            SecretName:  "<UNSET>",
                        },
                    },
                },
            },
            volumeMounts: []v1.VolumeMount{
                {
                    Name:      "pki",
                    MountPath: "/etc/pki/ca-trust/source/anchors2/",
                },
            },
        },

        "docker.json": {
            volumes: []v1.Volume{
                {
                    Name: "docker.json",
                    VolumeSource: v1.VolumeSource{
                        Secret: &v1.SecretVolumeSource{
                            DefaultMode: ptrInt32(444),
                            SecretName:  "<UNSET>",
                        },
                    },
                },
            },
            volumeMounts: []v1.VolumeMount{
                {
                    Name:      "docker.json",
                    MountPath: filepath.Join(cosaSrvDir, "secrets", "auths"),
                },
            },
            requireData: []string{"docker.json"},
        },

        "koji-ca": {
            volumes: []v1.Volume{
                {
                    Name: "koji-ca",
                    VolumeSource: v1.VolumeSource{
                        ConfigMap: &v1.ConfigMapVolumeSource{
                            LocalObjectReference: v1.LocalObjectReference{
                                Name: "<UNSET>",
                            },
                        },
                    },
                },
            },
            volumeMounts: []v1.VolumeMount{
                {
                    Name:      "koji-ca",
                    MountPath: "/etc/pki/brew",
                },
            },
        },

        "koji-config": {
            volumes: []v1.Volume{
                {
                    Name: "koji-config",
                    VolumeSource: v1.VolumeSource{
                        ConfigMap: &v1.ConfigMapVolumeSource{
                            LocalObjectReference: v1.LocalObjectReference{
                                Name: "<UNSET>",
                            },
                        },
                    },
                },
            },
            volumeMounts: []v1.VolumeMount{
                {
                    Name:      "koji-config",
                    MountPath: "/etc/koji.conf.d",
                },
            },
        },

        "krb5.conf": {
            volumes: []v1.Volume{
                {
                    Name: "koji-kerberos",
                    VolumeSource: v1.VolumeSource{
                        ConfigMap: &v1.ConfigMapVolumeSource{
                            LocalObjectReference: v1.LocalObjectReference{
                                Name: "<UNSET>",
                            },
                        },
                    },
                },
            },
            volumeMounts: []v1.VolumeMount{
                {
                    Name:      "koji-kerberos",
                    MountPath: "/etc/krb5.conf.d",
                },
            },
        },
    }
)
```

## func GetClient

```go
func GetClient(ctx ClusterContext) (*kubernetes.Clientset, string, error)
```

GetClient fetches the Kubernetes Client from a ClusterContext\.

## func checkPort

```go
func checkPort(port int) error
```

checkPort checks if a port is open

## func clusterRunner

```go
func clusterRunner(term termChan, cp CosaPodder, envVars []v1.EnvVar) error
```

clusterRunner creates an OpenShift/Kubernetes pod for the work to be done\. The output of the pod is streamed and captured on the console\.

## func copyFile

```go
func copyFile(src, dest string) error
```

## func cosaInit

```go
func cosaInit() error
```

cosaInit does the initial COSA setup\. To support both pod and buildConfig based builds\, first check the API client\, then check envVars\. The use of envVars in this case is \*safe\*; \`SOURCE\_\{URI\,REF\} == apiBuild\.Spec\.Source\.Git\.\{URI\,REF\}\`\. That is\, SOURCE\_\* envVars will always match the apiBuild\.Spec\.Source\.Git\.\* values\.

## func decompress

```go
func decompress(in io.ReadCloser, dir string) error
```

decompress takes an io\.ReadCloser extracts its to directory\.

## func getHostname

```go
func getHostname() string
```

getHostname gets the current hostname

## func getLocalFileStamp

```go
func getLocalFileStamp(path string) (int64, error)
```

getLocalFileStamp returns the local file mod time in UTC Unix epic nanoseconds\.

## func getNetIP

```go
func getNetIP() (string, error)
```

getNetIP gets the IPV4 address of a pod when the pod's service account lacks permissions to obtain its own IP address\.

## func getPodIP

```go
func getPodIP(cs *kubernetes.Clientset, podNamespace, podName string) (string, error)
```

getPodIP returns the IP of a pod\. getPodIP blocks pending until the podIP is recieved\.

## func getPortOrNext

```go
func getPortOrNext(port int) int
```

getNextPort iterates and finds the next available port

## func getPushTagless

```go
func getPushTagless(s string) (string, string)
```

getPushTagless returns the registry\, and push path i\.e registry\.svc:5000/image/bar:tag returns "registry\.svc:5000" and "image/bar"

## func init

```go
func init()
```

## func isKnownBuildMeta

```go
func isKnownBuildMeta(n string) bool
```

isKnownBuildMeta checks if n is known and should be fetched and returned by pods via Minio\.

## func k8sInClusterClient

```go
func k8sInClusterClient() (*kubernetes.Clientset, string, error)
```

k8sInClusterClient opens an in\-cluster Kubernetes API client\. The running pod must have a service account defined in the PodSpec\.

## func kubernetesSecretsSetup

```go
func kubernetesSecretsSetup(ac *kubernetes.Clientset, ns, toDir string) ([]string, error)
```

kubernetesSecretSetup looks for matching secrets in the environment matching 'coreos\-assembler\.coreos\.com/secret=k' and then maps the secret automatically in\. "k" must be in the "known" secrets type to be mapped automatically\.

## func mustHaveImage

```go
func mustHaveImage(ctx context.Context, image string) error
```

mustHaveImage pulls the image if it is not found

## func newFileStamp

```go
func newFileStamp() string
```

newFileStamp returns the Unix nanoseconds of the file as a string We use Unix nanoseconds for precision\.

## func ocpBuildClient

```go
func ocpBuildClient() error
```

ocpBuildClient initalizes the OpenShift Build Client API\.

## func podmanRunner

```go
func podmanRunner(term termChan, cp CosaPodder, envVars []v1.EnvVar) error
```

podmanRunner runs the work in a Podman container using workDir as \`/srv\` \`podman kube play\` does not work well due to permission mappings; there is no way to do id mappings\.

## func ptrBool

```go
func ptrBool(b bool) *bool
```

## func ptrInt

```go
func ptrInt(i int64) *int64
```

## func ptrInt32

```go
func ptrInt32(i int32) *int32
```

ptrInt32 converts an int32 to a ptr of the int32

## func pushOstreeToRegistry

```go
func pushOstreeToRegistry(ctx ClusterContext, push *spec.Registry, build *cosa.Build) error
```

pushOstreetoRegistry pushes the OStree to the defined registry location\.

## func randomString

```go
func randomString(n int) (string, error)
```

## func recieveInputBinary

```go
func recieveInputBinary() (string, error)
```

extractInputBinary processes the provided input stream as directed by BinaryBuildSource into dir\. OpenShift sends binary builds over stdin\. To make our life easier\, use the OpenShift API to process the input\. Returns the name of the file written\.

## func sshForwarder

```go
func sshForwarder(ctx context.Context, cfg *SSHForwardPort) (chan<- bool, error)
```

sshForwarder is a generic forwarder from the local host to a remote host

## func streamPodLogs

```go
func streamPodLogs(client *kubernetes.Clientset, namespace string, pod *v1.Pod, term termChan) error
```

streamPodLogs steams the pod's logs to logging and to disk\. Worker pods are responsible for their work\, but not for their logs\. To make streamPodLogs thread safe and non\-blocking\, it expects a pointer to a bool\. If that pointer is nil or true\, then we return\.

## func tokenRegistryLogin

```go
func tokenRegistryLogin(ctx ClusterContext, tlsVerify *bool, registry string) error
```

tokenRegistryLogin logins to a registry using a service account

## func uploadCustomBuildContainer

```go
func uploadCustomBuildContainer(ctx ClusterContext, tlsVerify *bool, apiBuild *buildapiv1.Build, build *cosa.Build) error
```

uploadCustomBuildContainer implements the custom build strategy optional step to report the results to the registry as an OCI image\. uploadCustomBuildContainer must be called from a worker pod\. The token used is associated with the service account with the worker pod\.

## func uploadPathAsTarBall

```go
func uploadPathAsTarBall(ctx context.Context, bucket, object, path, workDir string, sudo bool, r *Return) error
```

uploadPathAsTarBall returns a path as a tarball to minio server\. This uses a shell call out since we need to elevate permissions via sudo \(bug in Golang \<1\.16 prevents elevating privs\)\. Gangplank runs as the builder user normally and since some files are written by root\, Gangplank will get permission denied\.

The tarball creation will be done relative to workDir\. If workDir is an empty string\, it will default to the current working directory\.

## func writeDockerSecret

```go
func writeDockerSecret(ctx ClusterContext, clusterSecretName, authPath string) error
```

writeDockerSecret writes the \.dockerCfg or \.dockerconfig to the correct path\. It accepts the cluster context\, the name of the secret and the location to write to\.

## func writeToWriters

```go
func writeToWriters(l *log.Entry, in io.ReadCloser, outs ...io.Writer) <-chan error
```

writeToWriters writes in to outs until in or outs are closed\. When run a go\-routine\, calls can terminate by closing "in"\.

## type Builder

Builder implements the Build

```go
type Builder interface {
    Exec(ctx ClusterContext) error
}
```

buildConfig is a builder\.

```go
var _ Builder = &buildConfig{}
```

workSpec is a Builder\.

```go
var _ Builder = &workSpec{}
```

### func NewBuilder

```go
func NewBuilder(ctx ClusterContext) (Builder, error)
```

NewBuilder returns a Builder\. NewBuilder determines what "Builder" to return by first trying Worker and then an OpenShift builder\.

## type Cluster

Cluster describes a Kubnetenes Cluster\.

```go
type Cluster struct {
    cs         *kubernetes.Clientset
    nameSpace  string
    kubeConfig string

    // inCluster indicates the client should use the Kubernetes in-cluster client
    inCluster bool

    // remoteCluster indicates Gangplank should run the supervising Gangplank in pod
    remoteCluster bool

    // podman indicates that the container should be built using Podman
    podman bool

    // podmanSrvDir is the scratch workdir for podman and is bind-mounted
    // in as /srv.
    podmanSrvDir string

    stdIn  *os.File
    stdOut *os.File
    stdErr *os.File
}
```

### func GetCluster

```go
func GetCluster(ctx ClusterContext) (*Cluster, error)
```

GetCluster fetches the Cluster options from the Context

### func \(\*Cluster\) GetStdIO

```go
func (c *Cluster) GetStdIO() (*os.File, *os.File, *os.File)
```

GetStdIO returns the stdIO options

### func \(\*Cluster\) SetPodman

```go
func (c *Cluster) SetPodman(srvDir string)
```

SetPodman forces out\-of\-cluster execution via Podman\.

### func \(\*Cluster\) SetRemoteCluster

```go
func (c *Cluster) SetRemoteCluster(kubeConfig, namespace string)
```

SetRemote uses a remote cluster

### func \(\*Cluster\) SetStdIO

```go
func (c *Cluster) SetStdIO(stdIn, stdOut, stdErr *os.File)
```

SetStdIO sets the IO options TODO: Implement for \`cosa remote\`

### func \(\*Cluster\) toKubernetesCluster

```go
func (c *Cluster) toKubernetesCluster() *KubernetesCluster
```

toKubernetesCluster casts the cluster to the interface

## type ClusterContext

ClusterContext is a context

```go
type ClusterContext context.Context
```

### func NewClusterContext

```go
func NewClusterContext(ctx context.Context, kc KubernetesCluster) ClusterContext
```

NewClusterContext context with cluster options\.

## type CosaPodder

CosaPodder create COSA capable pods\.

```go
type CosaPodder interface {
    WorkerRunner(term termChan, envVar []v1.EnvVar) error
    GetClusterCtx() ClusterContext
    getPodSpec([]v1.EnvVar) (*v1.Pod, error)
}
```

a cosaPod is a CosaPodder

```go
var _ CosaPodder = &cosaPod{}
```

hopPod implements the CosaPodder interface\.

```go
var _ CosaPodder = &hopPod{}
```

### func NewCosaPodder

```go
func NewCosaPodder(
    ctx ClusterContext,
    apiBuild *buildapiv1.Build,
    index int) (CosaPodder, error)
```

NewCosaPodder creates a CosaPodder

### func NewHopPod

```go
func NewHopPod(ctx ClusterContext, image, serviceAccount, workDir string, js *spec.JobSpec) CosaPodder
```

NewHopPod returns a PodBuilder\.

## type KubernetesCluster

KubernetesCluster is the Gangplank interface to using a cluster\.

```go
type KubernetesCluster interface {
    SetStdIO(stdIn, stdOut, stdErr *os.File)
    GetStdIO() (*os.File, *os.File, *os.File)
    SetPodman(srvDir string)
    SetRemoteCluster(kubeConfig string, namespace string)
}
```

Cluster implements a KubernetesCluster

```go
var _ KubernetesCluster = &Cluster{}
```

### func NewCluster

```go
func NewCluster(inCluster bool) KubernetesCluster
```

NewCluster returns a Kubernetes cluster

## type PodBuilder

PodBuilder is the manual/unbounded Build interface\. A PodBuilder uses a build\.openshift\.io/v1 Build interface to use the exact same code path between the two\.

```go
type PodBuilder interface {
    Exec(ctx ClusterContext) error
}
```

cli is a Builder \(and a poor one at that too\.\.\.\) While a ClusterPodBuilder is a Builder\, we treat it seperately\.

```go
var _ PodBuilder = &podBuild{}
```

### func NewPodBuilder

```go
func NewPodBuilder(ctx ClusterContext, image, serviceAccount, workDir string, js *spec.JobSpec) (PodBuilder, error)
```

NewPodBuilder returns a ClusterPodBuilder ready for execution\.

## type RemoteFile

RemoteFile is an object to fetch from a remote server

```go
type RemoteFile struct {
    Bucket     string         `json:"bucket,omitempty"`
    Object     string         `json:"object,omitempty"`
    Minio      *minioServer   `json:"remote,omitempty"`
    Compressed bool           `json:"comptempty"`
    Artifact   *cosa.Artifact `json:"artifact,omitempty"`

    // ForcePath forces writing to, or uncompressing to a specific path
    ForcePath string `json:"force_path,omitempty"`

    // ForcePath forces writing to, or uncompressing to a specific path
    ForceExtractPath string `json:"force_extract_path,omitempty"`
}
```

### func getBuildMeta

```go
func getBuildMeta(jsonPath, keyPathBase string, m *minioServer, l *log.Entry) []*RemoteFile
```

getBuildMeta searches a path for all build meta files and creates remoteFiles for them\. The keyPathBase is the relative path for the object\.

### func getStageFiles

```go
func getStageFiles(buildID string,
    l *log.Entry, m *minioServer, lastBuild *cosa.Build, s *spec.Stage) (*cosa.Build, []*RemoteFile, error)
```

getStageFiles returns the newest build and RemoteFiles for the stage\. Depending on the stages dependencies\, it will ensure that all meta\-data and artifacts are send\. If the stage requires/requests the caches\,  it will be included in the RemoteFiles\.

### func \(\*RemoteFile\) Extract

```go
func (r *RemoteFile) Extract(ctx context.Context, path string) error
```

Extract decompresses the remote file to the path\.

### func \(\*RemoteFile\) WriteToPath

```go
func (r *RemoteFile) WriteToPath(ctx context.Context, path string) error
```

WriteToPath fetches the remote file and writes it locally\.

## type Return

Return describes the location of where to send results\.

```go
type Return struct {
    Minio     *minioServer `json:"remote"`
    Bucket    string       `json:"bucket"`
    Overwrite bool         `json:"overwrite"`

    // ArtifactTypes will return only artifacts that known and defined
    // For example []string{"aws","azure"}
    ArtifactTypes []string `json:"artifacts"`

    // Return all files found in the builds directory
    All bool `json:"all"`
}
```

### func \(\*Return\) Run

```go
func (r *Return) Run(ctx context.Context, ws *workSpec) error
```

Run executes the report by walking the build path\.

## type Returner

Returner sends the results to the ReportServer

```go
type Returner interface {
    Run(ctx context.Context, ws *workSpec) error
}
```

Return is a Returner

```go
var _ Returner = &Return{}
```

## type SSHForwardPort

```go
type SSHForwardPort struct {
    Host string
    User string
    Key  string

    // port is not exported
    port int
}
```

### func getSshMinioForwarder

```go
func getSshMinioForwarder(j *spec.JobSpec) *SSHForwardPort
```

getSshMinioForwarder returns an SSHForwardPort from the jobspec definition for forwarding a minio server\, or nil if forwarding is not enabled\.

## type SecretMapper

SecretMapper maps a secretMap

```go
type SecretMapper interface {
    Setup() error
}
```

## type buildConfig

buildConfig represent the input into a buildConfig\.

```go
type buildConfig struct {
    JobSpecURL  string `envVar:"COSA_JOBSPEC_URL"`
    JobSpecRef  string `envVar:"COSA_JOBSPEC_REF"`
    JobSpecFile string `envVar:"COSA_JOBSPEC_FILE"`
    CosaCmds    string `envVar:"COSA_CMDS"`

    // Information about the parent pod
    PodName      string `envVar:"COSA_POD_NAME"`
    PodIP        string `envVar:"COSA_POD_IP"`
    PodNameSpace string `envVar:"COSA_POD_NAMESPACE"`

    // HostIP is the kubernetes IP address of the running pod.
    HostIP  string
    HostPod string

    // Internal copy of the JobSpec
    JobSpec spec.JobSpec

    ClusterCtx ClusterContext
}
```

### func newBC

```go
func newBC(ctx context.Context, c *Cluster) (*buildConfig, error)
```

newBC accepts a context and returns a buildConfig

### func \(\*buildConfig\) Exec

```go
func (bc *buildConfig) Exec(ctx ClusterContext) (err error)
```

Exec executes the command using the closure for the commands

### func \(\*buildConfig\) discoverStages

```go
func (bc *buildConfig) discoverStages(m *minioServer) ([]*RemoteFile, error)
```

discoverStages supports the envVar and \*\.cosa\.sh scripts as implied stages\. The envVar stage will be run first\, followed by the \`\*\.cosa\.sh\` scripts\.

### func \(\*buildConfig\) ocpBinaryInput

```go
func (bc *buildConfig) ocpBinaryInput(m *minioServer) ([]*RemoteFile, error)
```

ocpBinaryInput decompresses the binary input\. If the binary input is a tarball with an embedded JobSpec\, its extracted\, read and used\.

## type byteFields

byteField represents a configMap's data fields

```go
type byteFields map[string][]byte
```

## type clusterCtxKey

```go
type clusterCtxKey int
```

```go
const clusterObj clusterCtxKey = 0
```

## type consoleLogWriter

consoleLogWriter is an io\.Writer that emits fancy logs to a screen\.

```go
type consoleLogWriter struct {
    startTime time.Time
    prefix    string
}
```

### func newConsoleLogWriter

```go
func newConsoleLogWriter(prefix string) *consoleLogWriter
```

newConosleLogWriter is a helper function for getting a new writer\.

### func \(\*consoleLogWriter\) Write

```go
func (cw *consoleLogWriter) Write(b []byte) (int, error)
```

Write implements io\.Writer for Console Writer with

## type cosaPod

cosaPod is a COSA pod

```go
type cosaPod struct {
    apiBuild   *buildapiv1.Build
    clusterCtx ClusterContext

    ocpInitCommand  []string
    ocpRequirements v1.ResourceList
    ocpSecContext   *v1.SecurityContext
    volumes         []v1.Volume
    volumeMounts    []v1.VolumeMount

    index int
}
```

### func \(\*cosaPod\) GetClusterCtx

```go
func (cp *cosaPod) GetClusterCtx() ClusterContext
```

### func \(\*cosaPod\) WorkerRunner

```go
func (cp *cosaPod) WorkerRunner(term termChan, envVars []v1.EnvVar) error
```

WorkerRunner runs a worker pod on either OpenShift/Kubernetes or in as a podman container\.

### func \(\*cosaPod\) addVolumeFromObjectLabel

```go
func (cp *cosaPod) addVolumeFromObjectLabel(obj metav1.Object, fields stringFields) error
```

addVolumeFromObjectLabel is a helper that recieves an object and data and looks up the object's name from volMaps\. If a mapping is found\, then the object is added to cosaPod's definition\.

### func \(\*cosaPod\) addVolumesFromConfigMapLabels

```go
func (cp *cosaPod) addVolumesFromConfigMapLabels() error
```

addVolumesFromConfigMapLabels discovers configMaps with matching labels and if known\, adds the defined volume mount from volMaps\.

### func \(\*cosaPod\) addVolumesFromSecretLabels

```go
func (cp *cosaPod) addVolumesFromSecretLabels() error
```

addVolumesFromSecretLabels discovers secrets with matching labels and if known\, adds the defined volume mount from volMaps\.

### func \(\*cosaPod\) getPodSpec

```go
func (cp *cosaPod) getPodSpec(envVars []v1.EnvVar) (*v1.Pod, error)
```

getPodSpec returns a pod specification\.

## type hopPod

hopPod describes a remote pod for running Gangplank in a cluster remotely\.

```go
type hopPod struct {
    clusterCtx ClusterContext
    js         *spec.JobSpec

    image          string
    ns             string
    serviceAccount string
}
```

### func \(\*hopPod\) GetClusterCtx

```go
func (h *hopPod) GetClusterCtx() ClusterContext
```

GetClusterCtx returns the cluster context of a hopPod

### func \(\*hopPod\) WorkerRunner

```go
func (h *hopPod) WorkerRunner(term termChan, _ []v1.EnvVar) error
```

Exec Gangplank locally through a remote/hop pod that runs Gangplank in a cluster\.

### func \(\*hopPod\) getPodSpec

```go
func (h *hopPod) getPodSpec([]v1.EnvVar) (*v1.Pod, error)
```

getSpec createa a very generic pod that can run on any Cluster\. The pod will mimic a build api pod\.

## type minioServer

minioServer describes a Minio S3 Object stoarge to start\.

```go
type minioServer struct {
    AccessKey      string `json:"accesskey"`
    SecretKey      string `json:"secretkey"`
    Host           string `json:"host"`
    Port           int    `json:"port"`
    ExternalServer bool   `json:"external_server"` //indicates that a server should not be started
    Region         string `json:"region"`

    // overSSH describes how to forward the Minio Port over SSH
    // This option is only useful with envVar CONTAINER_HOST running
    // in podman mode.
    overSSH *SSHForwardPort
    // sshStopCh is used to shutdown the SSH port forwarding.
    sshStopCh chan<- bool

    dir          string
    minioOptions minio.Options
    cmd          *exec.Cmd
}
```

### func StartStandaloneMinioServer

```go
func StartStandaloneMinioServer(ctx context.Context, srvDir, cfgFile string, overSSH *SSHForwardPort) (*minioServer, error)
```

StartStanaloneMinioServer starts a standalone minio server\.

### func minioCfgFromFile

```go
func minioCfgFromFile(f string) (mk minioServer, err error)
```

minioCfgFromFile returns a minio configuration from a file

### func minioCfgReader

```go
func minioCfgReader(in io.Reader) (m minioServer, err error)
```

minioKeysReader takes an io\.Reader and returns a minio cfg

### func newMinioServer

```go
func newMinioServer(cfgFile string) *minioServer
```

newMinioSever defines an ephemeral minioServer from a config or creates a new one\. To prevent random pods/people accessing or relying on the server\, we use entirely random keys\.

### func \(\*minioServer\) Exists

```go
func (m *minioServer) Exists(bucket, object string) bool
```

Exists check if bucket/object exists\.

### func \(\*minioServer\) Kill

```go
func (m *minioServer) Kill()
```

Kill terminates the minio server\.

### func \(\*minioServer\) Wait

```go
func (m *minioServer) Wait()
```

Wait blocks until Minio is finished\.

### func \(\*minioServer\) WriteJSON

```go
func (m *minioServer) WriteJSON(w io.Writer) error
```

WriteJSON returns the jobspec

### func \(\*minioServer\) WriteToFile

```go
func (m *minioServer) WriteToFile(f string) error
```

minioKeysFromFile writes the minio keys to a file

### func \(\*minioServer\) client

```go
func (m *minioServer) client() (*minio.Client, error)
```

GetClient returns a Minio Client

### func \(\*minioServer\) ensureBucketExists

```go
func (m *minioServer) ensureBucketExists(ctx context.Context, bucket string) error
```

### func \(\*minioServer\) exec

```go
func (m *minioServer) exec(ctx context.Context) error
```

exec runs the minio command

### func \(\*minioServer\) fetcher

```go
func (m *minioServer) fetcher(ctx context.Context, bucket, object string, dest io.Writer) error
```

fetcher retrieves an object from a Minio server

### func \(\*minioServer\) getStamp

```go
func (m *minioServer) getStamp(bucket, object string) (int64, error)
```

getStamp returns the stamp\. If the file does not exist remotely the stamp of zero is returned\. If the file exists but has not been stamped\, then UTC Unix epic in nanoseconds of the modification time is used \(the stamps are lost when the minio instance is reaped\)\. The obvious flaw is that this does require all hosts to have coordinate time; this should be the case for Kubernetes cluster and podman based builds will always use the same time source\.

### func \(\*minioServer\) isLocalNewer

```go
func (m *minioServer) isLocalNewer(bucket, object string, path string) (bool, error)
```

isLocalNewer checks if the file is newer than the remote file\, if any\. If the file does not exist remotely\, then it is considered newer\.

### func \(\*minioServer\) putter

```go
func (m *minioServer) putter(ctx context.Context, bucket, object, fpath string) error
```

putter uploads the contents of an io\.Reader to a remote MinioServer

### func \(\*minioServer\) stampFile

```go
func (m *minioServer) stampFile(bucket, object string) error
```

stampFile add the unique stamp

### func \(\*minioServer\) start

```go
func (m *minioServer) start(ctx context.Context) error
```

start executes the minio server and returns an error if not ready\.

## type mountReferance

mountReferance is mapping of secrets or a configmap

```go
type mountReferance struct {
    volumes         []v1.Volume
    volumeMounts    []v1.VolumeMount
    requireData     []string
    addInitCommands []string
}
```

## type outWriteCloser

outWriteCloser is a noop closer

```go
type outWriteCloser struct {
    *os.File
}
```

### func newNoopFileWriterCloser

```go
func newNoopFileWriterCloser(f *os.File) *outWriteCloser
```

### func \(\*outWriteCloser\) Close

```go
func (o *outWriteCloser) Close() error
```

## type podBuild

```go
type podBuild struct {
    apibuild *buildapiv1.Build
    bc       *buildConfig
    js       *spec.JobSpec

    clusterCtx ClusterContext
    pod        *v1.Pod

    hostname         string
    image            string
    ipaddr           string
    projectNamespace string
    serviceAccount   string
    workDir          string
}
```

### func \(\*podBuild\) Exec

```go
func (pb *podBuild) Exec(ctx ClusterContext) error
```

Exec starts the unbounded build\.

### func \(\*podBuild\) encodeAPIBuild

```go
func (pb *podBuild) encodeAPIBuild() (string, error)
```

encodeAPIBuilder the ci buildapiv1 object to a JSON object\. JSON is the messaginging interface for Kubernetes\.

### func \(\*podBuild\) generateAPIBuild

```go
func (pb *podBuild) generateAPIBuild() error
```

generateAPIBuild creates a "mock" buildconfig\.openshift\.io/v1 Kubernetes object that is consumed by \`bc\.go\`\.

### func \(\*podBuild\) setInCluster

```go
func (pb *podBuild) setInCluster() error
```

setInCluster does the nessasary setup for unbounded builder running as an in\-cluster build\.

## type podmanRunnerFunc

```go
type podmanRunnerFunc func(termChan, CosaPodder, []v1.EnvVar) error
```

podmanFunc is set to unimplemented by default\.

```go
var podmanFunc podmanRunnerFunc = func(termChan, CosaPodder, []v1.EnvVar) error {
    return errors.New("build was not compiled with podman supprt")
}
```

## type secretMap

```go
type secretMap struct {
    label      string
    envVarMap  varMap
    fileVarMap varMap
}
```

### func getSecretMapping

```go
func getSecretMapping(s string) (*secretMap, bool)
```

Get SecretMapping returns the secretMap and true if found\.

### func \(\*secretMap\) writeSecretEnvVars

```go
func (sm *secretMap) writeSecretEnvVars(d map[string][]byte, ret *[]string) error
```

writeSecretEnvVars creates envVars\.

### func \(\*secretMap\) writeSecretFiles

```go
func (sm *secretMap) writeSecretFiles(toDir, name string, d map[string][]byte, ret *[]string) error
```

writeSecretFiles writes secrets to their location based on the map\.

## type stringFields

stringFields represent a secret's data fields

```go
type stringFields map[string]string
```

### func toStringFields

```go
func toStringFields(bf byteFields) stringFields
```

toStringFields is used to convert from a byteFields to a stringFields

## type termChan

termChan is a channel used to singal a termination

```go
type termChan <-chan bool
```

## type varMap

```go
type varMap map[string]string
```

## type workSpec

workSpec define job for remote worker to do A workSpec is dispatched by a builder and is tightly coupled to to the dispatching pod\.

```go
type workSpec struct {
    RemoteFiles   []*RemoteFile     `json:"remotefiles"`
    JobSpec       spec.JobSpec      `json:"jobspec"`
    ExecuteStages []string          `json:"executeStages"`
    APIBuild      *buildapiv1.Build `json:"apiBuild"`
    Return        *Return           `json:"return"`
}
```

### func newWorkSpec

```go
func newWorkSpec(ctx ClusterContext) (*workSpec, error)
```

newWorkSpec returns a workspec from the environment

### func \(\*workSpec\) Exec

```go
func (ws *workSpec) Exec(ctx ClusterContext) error
```

Exec executes the work spec tasks\.

### func \(\*workSpec\) Marshal

```go
func (ws *workSpec) Marshal() ([]byte, error)
```

Marshal returns the JSON of a WorkSpec\.

### func \(\*workSpec\) Unmarshal

```go
func (ws *workSpec) Unmarshal(r io.Reader) error
```

Unmarshal decodes an io\.Reader to a workSpec\.

### func \(\*workSpec\) getEnvVars

```go
func (ws *workSpec) getEnvVars() ([]v1.EnvVar, error)
```

getEnvVars returns the envVars to be exposed to the worker pod\. When \`newWorkSpec\` is called\, the envVar will read the embedded string JSON and the worker will get its configuration\.



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
